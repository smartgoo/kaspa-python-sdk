# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import enum
import typing

@typing.final
class AccountKind:
    r"""
    Account kind is a string signature that represents an account type.
    Account kind is used to identify the account type during
    serialization, deserialization and various API calls.
    
    Note:
        Supported values:
    
        - `legacy`: Legacy account type
        - `bip32`: BIP-32 HD wallet account
        - `multisig`: Multi-signature account
        - `keypair`: Simple keypair account
        - `bip32watch`: Watch-only BIP-32 account
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, kind: builtins.str) -> AccountKind:
        r"""
        Create a new AccountKind from a string.
        
        Args:
            kind: The account kind string.
        
        Returns:
            AccountKind: A new AccountKind instance.
        
        Raises:
            Exception: If the kind string is invalid.
        """
    def __str__(self) -> builtins.str:
        r"""
        The string representation.
        
        Returns:
            str: The account kind as a string.
        """
    def to_string(self) -> builtins.str:
        r"""
        Get the string representation.
        
        Returns:
            str: The account kind as a string.
        """

@typing.final
class Address:
    r"""
    A Kaspa blockchain address.
    
    In string form, the Kaspa addresses are represented by a `bech32`-encoded
    address string combined with a network type prefix. The `bech32` string encoding is
    comprised of a public key, the public key version and the resulting checksum.
    """
    @property
    def version(self) -> builtins.str:
        r"""
        The string representation of the address version.
        Versions are `PubKey`, `PubKeyECDSA`, or `ScriptHash`.
        
        Returns:
            str: The address version.
        """
    @property
    def prefix(self) -> builtins.str:
        r"""
        The network prefix of the address. Prefix is based on the network type (mainnet, testnet, etc..)
        
        Returns:
            str: The network prefix string.
        
        Note:
            - Mainnet prefix is `kaspa`
            - Testnet prefix is `kaspatest`
            - Simnet prefix is `kaspasim`
            - Devnet prefix is `kaspadev`
        """
    @prefix.setter
    def prefix(self, value: builtins.str) -> None:
        r"""
        Set the network prefix of the address.
        
        Args:
            value: The network prefix string (e.g., `kaspa`, `kaspatest`, `kaspadev`).
        
        Raises:
            Exception: If the prefix string is invalid.
        """
    @property
    def payload(self) -> builtins.str:
        r"""
        The bech32 encoded payload of the address.
        
        Returns:
            str: The payload portion of the address.
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, address: builtins.str) -> Address:
        r"""
        Create a new Address from a string.
        
        Args:
            address: A valid Kaspa address string.
        
        Returns:
            Address: A new Address instance.
        
        Raises:
            Exception: If the address string is invalid.
        """
    @staticmethod
    def validate(address: builtins.str) -> builtins.bool:
        r"""
        Check if an address string is valid.
        
        Args:
            address: A Kaspa address string to validate.
        
        Returns:
            bool: True if the address is valid, False otherwise.
        """
    def to_string(self) -> builtins.str:
        r"""
        The string representation of the Address.
        
        Returns:
            str: A bech32 encoded Kaspa address string.
        """
    def short(self, n: builtins.int) -> builtins.str:
        r"""
        Get a shortened representation of the address.
        
        Args:
            n: The number of characters to show at the start and end of the payload.
        
        Returns:
            str: A shortened address string in the format `prefix:start....end`.
        """
    def __str__(self) -> builtins.str:
        r"""
        The string representation.
        
        Returns:
            str: The address as a string
        """

@typing.final
class Balance:
    r"""
    UTXO context balance summary.
    """
    @property
    def mature(self) -> builtins.int:
        r"""
        Total mature balance in sompi.
        """
    @property
    def pending(self) -> builtins.int:
        r"""
        Total pending balance in sompi.
        """
    @property
    def outgoing(self) -> builtins.int:
        r"""
        Total outgoing balance in sompi.
        """
    @property
    def mature_utxo_count(self) -> builtins.int:
        r"""
        Number of mature UTXOs.
        """
    @property
    def pending_utxo_count(self) -> builtins.int:
        r"""
        Number of pending UTXOs.
        """
    @property
    def stasis_utxo_count(self) -> builtins.int:
        r"""
        Number of stasis (coinbase) UTXOs.
        """

@typing.final
class BalanceStrings:
    r"""
    String-formatted balance values with network suffix.
    """
    @property
    def mature(self) -> builtins.str:
        r"""
        Mature balance formatted as a string (e.g., "1.23 KAS").
        """
    @property
    def pending(self) -> typing.Optional[builtins.str]:
        r"""
        Pending balance formatted as a string (if any).
        """

@typing.final
class Binary:
    r"""
    Binary data type for flexible input handling.
    
    This type is not intended to be instantiated directly from Python.
    It serves as a helper type that allows Rust functions to accept binary
    data in multiple convenient forms from Python.
    
    Accepts:
        - str: A hexadecimal string (e.g., "deadbeef").
        - bytes: Python bytes object.
        - list[int]: A list of byte values (0-255).
    """
    ...

@typing.final
class DerivationPath:
    r"""
    A BIP-32 derivation path for hierarchical key derivation.
    
    Represents a path like "m/44'/111111'/0'/0/0" for deriving keys.
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, path: builtins.str) -> DerivationPath:
        r"""
        Create a derivation path from a string.
        
        Args:
            path: A path string (e.g., "m/44'/111111'/0'").
        
        Returns:
            DerivationPath: A new DerivationPath instance.
        
        Raises:
            Exception: If the path format is invalid.
        """
    def is_empty(self) -> builtins.bool:
        r"""
        Check if the path is empty (no components).
        
        Returns:
            bool: True if empty.
        """
    def length(self) -> builtins.int:
        r"""
        Get the number of path components.
        
        Returns:
            int: The path length.
        """
    def parent(self) -> typing.Optional[DerivationPath]:
        r"""
        Get the parent path (one level up).
        
        Returns:
            DerivationPath | None: The parent path, or None if at root.
        """
    def push(self, child_number: builtins.int, hardened: typing.Optional[builtins.bool] = None) -> None:
        r"""
        Append a child index to the path.
        
        Args:
            child_number: The child index.
            hardened: Whether to use hardened derivation (default: False).
        
        Raises:
            Exception: If the child number is invalid.
        """
    def to_string(self) -> builtins.str:
        r"""
        Convert to string representation.
        
        Returns:
            str: The path as a string (e.g., "m/44'/111111'/0'").
        """

@typing.final
class Generator:
    r"""
    Transaction generator for building and signing transactions.
    
    Handles UTXO selection, fee calculation, change outputs, and transaction
    splitting for large transfers.
    """
    def __new__(cls, network_id: NetworkId, entries: UtxoEntries, change_address: Address, outputs: typing.Optional[Outputs] = None, payload: typing.Optional[Binary] = None, fee_rate: typing.Optional[builtins.float] = None, priority_fee: typing.Optional[builtins.int] = None, priority_entries: typing.Optional[UtxoEntries] = None, sig_op_count: typing.Optional[builtins.int] = None, minimum_signatures: typing.Optional[builtins.int] = None) -> Generator:
        r"""
        Create a new transaction generator.
        
        Args:
            network_id: The network to build transactions for.
            entries: List of UTXO entries to spend from.
            change_address: Address to send change to.
            outputs: Optional list of payment outputs.
            payload: Optional transaction payload (OP_RETURN data).
            fee_rate: Optional fee rate multiplier.
            priority_fee: Additional fee in sompi.
            priority_entries: UTXOs to use first.
            sig_op_count: Signature operations per input (default: 1).
            minimum_signatures: For multisig fee estimation.
        
        Returns:
            Generator: A new Generator instance.
        
        Raises:
            Exception: If generator creation fails.
        """
    def estimate(self) -> GeneratorSummary:
        r"""
        Estimate the transaction without generating.
        
        Returns:
            GeneratorSummary: A summary with fee, transaction count, and other details.
        
        Raises:
            Exception: If estimation fails.
        """
    def summary(self) -> GeneratorSummary:
        r"""
        Get the summary after generation.
        
        Returns:
            GeneratorSummary: The generation summary with fees and transaction details.
        """
    def __iter__(self) -> Generator:
        r"""
        Return self as an iterator.
        """
    def __next__(self) -> typing.Optional[PendingTransaction]:
        r"""
        Get the next pending transaction, or None if complete.
        
        Returns:
            PendingTransaction | None: The next transaction to sign and submit.
        
        Raises:
            Exception: If transaction generation fails.
        """

@typing.final
class GeneratorSummary:
    r"""
    A class containing a summary produced by transaction Generator.
    
    This class contains the number of transactions, the aggregated fees,
    the aggregated UTXOs and the final transaction amount that includes
    both network and QoS (priority) fees.
    
    See Also:
        create_transactions, Generator
    """
    @property
    def network_type(self) -> builtins.str:
        r"""
        The network type used for generation.
        
        Returns:
            str: The network type string.
        """
    @property
    def utxos(self) -> builtins.int:
        r"""
        The total number of UTXOs consumed.
        
        Returns:
            int: The UTXO count.
        """
    @property
    def fees(self) -> builtins.int:
        r"""
        The total fees across all generated transactions in sompi.
        
        Returns:
            int: The aggregate fee amount.
        """
    @property
    def transactions(self) -> builtins.int:
        r"""
        The number of transactions generated.
        
        Returns:
            int: The transaction count.
        """
    @property
    def final_amount(self) -> typing.Optional[builtins.int]:
        r"""
        The final transaction amount in sompi.
        
        Returns:
            int | None: The final amount, or None if not applicable.
        """
    @property
    def final_transaction_id(self) -> typing.Optional[builtins.str]:
        r"""
        The ID of the final transaction.
        
        Returns:
            str | None: The transaction ID, or None if not yet generated.
        """
    def __eq__(self, other: GeneratorSummary) -> builtins.bool: ...

@typing.final
class Hash:
    r"""
    A 32-byte hash value.
    
    Used for transaction IDs, block hashes, and other cryptographic purposes.
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, hex_str: builtins.str) -> Hash:
        r"""
        Create a new Hash from a hex string.
        
        Args:
            hex_str: A 64-character hex string representing the hash.
        
        Returns:
            Hash: A new Hash instance.
        
        Raises:
            Exception: If the hex string is invalid.
        """
    def to_string(self) -> builtins.str:
        r"""
        Convert the hash to a hex string.
        
        Returns:
            str: A 64-character hex string.
        """
    def __str__(self) -> builtins.str:
        r"""
        The string representation.
        
        Returns:
            str: The Hash as a hex string
        """
    def __bytes__(self) -> bytes:
        r"""
        The byte representation
        """

@typing.final
class Keypair:
    r"""
    A cryptographic keypair containing private and public keys.
    
    Provides convenient access to all key forms needed for signing
    and address generation.
    """
    @property
    def xonly_public_key(self) -> builtins.str:
        r"""
        The x-only public key as hex.
        
        Returns:
            str: The x-only public key.
        """
    @property
    def public_key(self) -> builtins.str:
        r"""
        The full public key as hex.
        
        Returns:
            str: The public key.
        """
    @property
    def private_key(self) -> builtins.str:
        r"""
        The private key as hex.
        
        Returns:
            str: The private key.
        """
    def __new__(cls, secret_key: builtins.str, public_key: builtins.str, xonly_public_key: builtins.str) -> Keypair:
        r"""
        Create a keypair from hex string representations.
        
        Args:
            secret_key: The secret key as hex.
            public_key: The public key as hex.
            xonly_public_key: The x-only public key as hex.
        
        Returns:
            Keypair: A new Keypair instance.
        
        Raises:
            Exception: If any key format is invalid.
        """
    def to_address(self, network: str | NetworkType) -> Address:
        r"""
        Derive a Schnorr address from this keypair.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived Schnorr address.
        """
    def to_address_ecdsa(self, network: str | NetworkType) -> Address:
        r"""
        Derive an ECDSA address from this keypair.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived ECDSA address.
        """
    @staticmethod
    def random() -> Keypair:
        r"""
        Generate a random keypair.
        
        Returns:
            Keypair: A new random Keypair.
        """
    @staticmethod
    def from_private_key(private_key: PrivateKey) -> Keypair:
        r"""
        Create a keypair from a private key.
        
        Args:
            private_key: The private key to derive from.
        
        Returns:
            Keypair: A new Keypair with derived public keys.
        
        Raises:
            Exception: If derivation fails.
        """

@typing.final
class Mnemonic:
    r"""
    A BIP-39 mnemonic seed phrase.
    
    Mnemonic phrases (also called seed phrases or recovery phrases) are
    human-readable representations of cryptographic seeds used for HD wallet
    generation.
    """
    @property
    def entropy(self) -> builtins.str:
        r"""
        The entropy bytes as a hex string.
        
        Returns:
            str: The raw entropy in hexadecimal.
        """
    @entropy.setter
    def entropy(self, value: builtins.str) -> None:
        r"""
        Set the entropy directly.
        
        Args:
            value: The entropy as a hex string (16 or 32 bytes).
        """
    @property
    def phrase(self) -> builtins.str:
        r"""
        The mnemonic phrase as a string.
        
        Returns:
            str: The space-separated word phrase.
        """
    @phrase.setter
    def phrase(self, value: builtins.str) -> None:
        r"""
        Set the mnemonic phrase.
        
        Args:
            value: The mnemonic phrase string.
        """
    def __new__(cls, phrase: builtins.str, language: str | Language = Language.English) -> Mnemonic:
        r"""
        Create a mnemonic from an existing phrase.
        
        Args:
            phrase: The mnemonic phrase string.
            language: Optional language for the phrase (default: English).
        
        Returns:
            Mnemonic: A new Mnemonic instance.
        
        Raises:
            Exception: If the phrase is invalid.
        """
    @staticmethod
    def validate(phrase: builtins.str, language: str | Language = Language.English) -> builtins.bool:
        r"""
        Validate a mnemonic phrase.
        
        Args:
            phrase: The mnemonic phrase to validate.
            language: Optional language for validation (default: English).
        
        Returns:
            bool: True if the phrase is valid, False otherwise.
        """
    @staticmethod
    def random(word_count: typing.Optional[builtins.int] = None) -> Mnemonic:
        r"""
        Generate a random mnemonic phrase.
        
        Args:
            word_count: Number of words (12, 15, 18, 21, or 24). Default: 24.
        
        Returns:
            Mnemonic: A new random mnemonic.
        
        Raises:
            Exception: If the word count is invalid.
        """
    def to_seed(self, password: typing.Optional[builtins.str] = None) -> builtins.str:
        r"""
        Convert the mnemonic to a seed for key derivation.
        
        Args:
            password: Optional passphrase for additional security.
        
        Returns:
            str: The seed as a hex string.
        
        Note:
            The same mnemonic with different passwords produces
            completely different seeds (and thus different wallets).
        """

@typing.final
class NetworkId:
    r"""
    Network identifier with optional suffix.
    
    Represents a specific Kaspa network, optionally with a numeric suffix
    for testnets (e.g., "testnet-10", "testnet-11").
    """
    @property
    def network_type(self) -> NetworkType:
        r"""
        The base network type (Mainnet, Testnet, Devnet, Simnet).
        
        Returns:
            NetworkType: The network type.
        """
    @property
    def suffix(self) -> typing.Optional[builtins.int]:
        r"""
        The optional numeric suffix (e.g., 10 for testnet-10).
        
        Returns:
            int | None: The suffix, or None if not set.
        """
    @property
    def default_p2p_port(self) -> builtins.int:
        r"""
        The default P2P port for this network.
        
        Returns:
            int: The default P2P port number.
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, network_id: typing.Any) -> NetworkId:
        r"""
        Create a new NetworkId.
        
        Args:
            network_id: A network string ("mainnet", "testnet-10") or NetworkType.
        
        Returns:
            NetworkId: A new NetworkId instance.
        
        Raises:
            Exception: If the network_id format is invalid.
        """
    @staticmethod
    def with_suffix(network_type: str | NetworkType, suffix: builtins.int) -> NetworkId:
        r"""
        Create a NetworkId with a specific suffix.
        
        Args:
            network_type: The base network type.
            suffix: The numeric suffix (e.g., 10 for testnet-10).
        
        Returns:
            NetworkId: A new NetworkId with the specified suffix.
        """
    def is_mainnet(self) -> builtins.bool:
        r"""
        Check if this is the mainnet.
        
        Returns:
            bool: True if this is mainnet, False otherwise.
        """
    def to_prefixed(self) -> builtins.str:
        r"""
        Get the prefixed string representation (e.g., "kaspa-mainnet").
        
        Returns:
            str: The prefixed network identifier.
        """
    def to_string(self) -> builtins.str:
        r"""
        Get the string representation (e.g., "mainnet", "testnet-10").
        
        Returns:
            str: The network identifier string.
        """
    def address_prefix(self) -> builtins.str:
        r"""
        Get the address prefix for this network.
        
        Returns:
            str: The prefix string ("kaspa", "kaspatest", "kaspadev", or "kaspasim").
        """
    def __str__(self) -> builtins.str:
        r"""
        The string representation.
        
        Returns:
            str: The NetworkId as a string
        """

@typing.final
class Notification:
    r"""
    RPC notification wrapper for event callbacks.
    
    This type is not intended to be instantiated directly from Python.
    It wraps notifications received from the Kaspa node when subscribed
    to events via RpcClient. The notification data is automatically
    converted to a Python dict when passed to callback handlers.
    
    Notification types:
        - BlockAdded: A new block was added to the DAG.
        - FinalityConflict: A finality conflict was detected.
        - FinalityConflictResolved: A finality conflict was resolved.
        - NewBlockTemplate: A new block template is available.
        - PruningPointUtxoSetOverride: The pruning point UTXO set changed.
        - UtxosChanged: UTXOs in the subscribed addresses changed.
        - VirtualDaaScoreChanged: The virtual DAA score changed.
        - SinkBlueScoreChanged: The sink blue score changed.
        - VirtualChainChanged: The virtual chain changed.
    """
    ...

@typing.final
class Outputs:
    r"""
    Payment outputs collection for flexible input handling.
    
    This type is not intended to be instantiated directly from Python.
    It serves as a helper type that allows Rust functions to accept a list
    of payment outputs in multiple convenient forms.
    
    Accepts:
        list[PaymentOutput]: A list of PaymentOutput objects.
        list[dict]: A list of dicts with `address` and `amount` keys.
    """
    ...

@typing.final
class PSKT:
    r"""
    Partially Signed Kaspa Transaction
    """
    @property
    def role(self) -> builtins.str: ...
    @property
    def payload(self) -> builtins.str: ...
    def __new__(cls, payload: typing.Optional[typing.Any] = None) -> PSKT: ...
    def serialize(self) -> builtins.str: ...
    def creator(self) -> PSKT:
        r"""
        Change role to `CREATOR`
        """
    def to_constructor(self) -> PSKT:
        r"""
        Change role to `CONSTRUCTOR`
        """
    def to_updater(self) -> PSKT:
        r"""
        Change role to `UPDATER`
        """
    def to_signer(self) -> PSKT:
        r"""
        Change role to `SIGNER`
        """
    def to_combiner(self) -> PSKT:
        r"""
        Change role to `COMBINER`
        """
    def to_finalizer(self) -> PSKT:
        r"""
        Change role to `FINALIZER`
        """
    def to_extractor(self) -> PSKT:
        r"""
        Change role to `EXTRACTOR`
        """
    def fallback_lock_time(self, lock_time: builtins.int) -> PSKT: ...
    def inputs_modifiable(self) -> PSKT: ...
    def outputs_modifiable(self) -> PSKT: ...
    def no_more_inputs(self) -> PSKT: ...
    def no_more_outputs(self) -> PSKT: ...
    def input_and_redeem_script(self, input: TransactionInput, data: builtins.str) -> PSKT: ...
    def input(self, input: TransactionInput) -> PSKT: ...
    def output(self, output: TransactionOutput) -> PSKT: ...
    def set_sequence(self, n: builtins.int, input_index: builtins.int) -> PSKT: ...
    def calculate_id(self) -> Hash: ...
    def calculate_mass(self, data: NetworkId) -> builtins.int: ...

@typing.final
class PaymentOutput:
    r"""
    A payment destination with address and amount.
    
    Represents a single output in a transaction, specifying where funds
    should be sent and how much. Used with Generator and create_transactions.
    """
    def __eq__(self, other: PaymentOutput) -> builtins.bool: ...

@typing.final
class PendingTransaction:
    r"""
    A transaction ready for signing and submission.
    
    Created by iterating over a Generator. Contains the transaction
    along with metadata about fees, amounts, and UTXOs being spent.
    """
    @property
    def id(self) -> builtins.str:
        r"""
        The transaction ID (hash).
        
        Returns:
            str: The transaction ID as a hex string.
        """
    @property
    def payment_amount(self) -> typing.Optional[builtins.int]:
        r"""
        The total payment amount in sompi (excluding change and fees).
        
        Returns:
            int | None: The payment amount, or None for sweep transactions.
        """
    @property
    def change_amount(self) -> builtins.int:
        r"""
        The change amount returned to the sender in sompi.
        
        Returns:
            int: The change amount.
        """
    @property
    def fee_amount(self) -> builtins.int:
        r"""
        The transaction fee in sompi.
        
        Returns:
            int: The fee amount.
        """
    @property
    def mass(self) -> builtins.int:
        r"""
        The transaction mass (used for fee calculation).
        
        Returns:
            int: The transaction mass.
        """
    @property
    def minimum_signatures(self) -> builtins.int:
        r"""
        The minimum number of signatures required.
        
        Returns:
            int: The minimum signature count.
        """
    @property
    def aggregate_input_amount(self) -> builtins.int:
        r"""
        The total value of all inputs in sompi.
        
        Returns:
            int: The aggregate input amount.
        """
    @property
    def aggregate_output_amount(self) -> builtins.int:
        r"""
        The total value of all outputs in sompi.
        
        Returns:
            int: The aggregate output amount.
        """
    @property
    def transaction_type(self) -> builtins.str:
        r"""
        The transaction type: "batch" for intermediate or "final" for last.
        
        Returns:
            str: The transaction type.
        """
    @property
    def transaction(self) -> Transaction:
        r"""
        The underlying transaction object.
        
        Returns:
            Transaction: The transaction for manual inspection or modification.
        """
    def addresses(self) -> builtins.list[Address]:
        r"""
        Get the unique addresses referenced by this transaction's inputs.
        
        Returns:
            list[Address]: List of addresses.
        """
    def get_utxo_entries(self) -> builtins.list[UtxoEntryReference]:
        r"""
        Get the UTXO entries being spent by this transaction.
        
        Returns:
            list[UtxoEntryReference]: List of UTXO entries.
        """
    def create_input_signature(self, input_index: builtins.int, private_key: PrivateKey, sighash_type: str | SighashType | None = SighashType.All) -> builtins.str:
        r"""
        Create a signature for a specific input.
        
        Args:
            input_index: The index of the input to sign.
            private_key: The private key for signing.
            sighash_type: The signature hash type (default: All).
        
        Returns:
            str: The signature as a hex string.
        
        Raises:
            Exception: If signing fails.
        """
    def fill_input(self, input_index: builtins.int, signature_script: Binary) -> None:
        r"""
        Fill an input's signature script with a pre-computed signature.
        
        Args:
            input_index: The index of the input to fill.
            signature_script: The signature script bytes.
        
        Raises:
            Exception: If filling fails.
        """
    def sign_input(self, input_index: builtins.int, private_key: PrivateKey, sighash_type: str | SighashType | None = SighashType.All) -> None:
        r"""
        Sign a specific input with a private key.
        
        Args:
            input_index: The index of the input to sign.
            private_key: The private key for signing.
            sighash_type: The signature hash type (default: All).
        
        Raises:
            Exception: If signing fails.
        """
    def sign(self, private_keys: list, check_fully_signed: typing.Optional[builtins.bool] = None) -> None:
        r"""
        Sign all inputs with the provided private keys.
        
        Args:
            private_keys: List of PrivateKey objects for signing.
            check_fully_signed: Verify all inputs are signed (default: None).
        
        Raises:
            Exception: If signing fails or transaction is not fully signed.
        """
    def submit(self, rpc_client: RpcClient) -> typing.Any:
        r"""
        Submit the signed transaction to the network.
        
        Args:
            rpc_client: The RPC client for submission.
        
        Returns:
            str: The transaction ID on success (async).
        
        Raises:
            Exception: If submission fails.
        """

@typing.final
class PrivateKey:
    r"""
    A private key for signing transactions and messages.
    
    Private keys should be kept secret and never shared.
    """
    def __new__(cls, key: builtins.str) -> PrivateKey:
        r"""
        Create a private key from a hex string.
        
        Args:
            key: A 64-character hex string representing the secret key.
        
        Returns:
            PrivateKey: A new PrivateKey instance.
        
        Raises:
            Exception: If the hex string is invalid.
        """
    def to_string(self) -> builtins.str:
        r"""
        Convert to hex string representation.
        
        Returns:
            str: The private key as a hex string.
        """
    def to_public_key(self) -> PublicKey:
        r"""
        Derive the corresponding public key.
        
        Returns:
            PublicKey: The derived public key.
        
        Raises:
            Exception: If derivation fails.
        """
    def to_address(self, network: str | NetworkType) -> Address:
        r"""
        Derive a Schnorr address from this private key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived Schnorr address.
        
        Raises:
            Exception: If derivation fails.
        """
    def to_address_ecdsa(self, network: str | NetworkType) -> Address:
        r"""
        Derive an ECDSA address from this private key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived ECDSA address.
        
        Raises:
            Exception: If derivation fails.
        """
    def to_keypair(self) -> Keypair:
        r"""
        Create a Keypair from this private key.
        
        Returns:
            Keypair: A keypair containing this private key and derived public keys.
        
        Raises:
            Exception: If keypair creation fails.
        """

@typing.final
class PrivateKeyGenerator:
    r"""
    Generator for deriving private keys from an extended private key.
    
    Used for creating wallets that can sign transactions.
    """
    def __new__(cls, xprv: str | XPrv, is_multisig: builtins.bool, account_index: builtins.int, cosigner_index: typing.Optional[builtins.int] = None) -> PrivateKeyGenerator:
        r"""
        Create a new private key generator.
        
        Args:
            xprv: The master extended private key, as a string or XPrv instance.
            is_multisig: Whether this is for a multisig wallet.
            account_index: The account index to use.
            cosigner_index: Optional cosigner index for multisig.
        
        Returns:
            PrivateKeyGenerator: A new generator instance.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_key(self, index: builtins.int) -> PrivateKey:
        r"""
        Get a receive (external) private key at the given index.
        
        Args:
            index: The address index.
        
        Returns:
            PrivateKey: The private key at that index.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_key(self, index: builtins.int) -> PrivateKey:
        r"""
        Get a change (internal) private key at the given index.
        
        Args:
            index: The address index.
        
        Returns:
            PrivateKey: The private key at that index.
        
        Raises:
            Exception: If derivation fails.
        """

@typing.final
class PublicKey:
    r"""
    A public key for verifying signatures and deriving addresses.
    
    Can be created from a private key or parsed from a hex string.
    """
    def __new__(cls, key: builtins.str) -> PublicKey:
        r"""
        Create a public key from a hex string.
        
        Args:
            key: A hex-encoded public key string.
        
        Returns:
            PublicKey: A new PublicKey instance.
        
        Raises:
            Exception: If the hex string is invalid.
        """
    def to_string(self) -> builtins.str:
        r"""
        Convert to hex string representation.
        
        Returns:
            str: The public key as a hex string.
        """
    def to_address(self, network: str | NetworkType) -> Address:
        r"""
        Derive a Schnorr address from this public key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived Schnorr address.
        
        Raises:
            Exception: If address derivation fails.
        """
    def to_address_ecdsa(self, network: str | NetworkType) -> Address:
        r"""
        Derive an ECDSA address from this public key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived ECDSA address.
        
        Raises:
            Exception: If address derivation fails.
        """
    def to_x_only_public_key(self) -> XOnlyPublicKey:
        r"""
        Get the x-only public key (32 bytes, no parity byte).
        
        Returns:
            XOnlyPublicKey: The x-only representation.
        """
    def fingerprint(self) -> typing.Optional[builtins.str]:
        r"""
        Get the key fingerprint (first 4 bytes of hash).
        
        Returns:
            str | None: The fingerprint as hex, or None if unavailable.
        """

@typing.final
class PublicKeyGenerator:
    r"""
    Generator for deriving public keys and addresses from an extended public key.
    
    Useful for creating watch-only wallets that can generate addresses
    without access to private keys.
    """
    @staticmethod
    def from_xpub(kpub: builtins.str, cosigner_index: typing.Optional[builtins.int] = None) -> PublicKeyGenerator:
        r"""
        Create a generator from an extended public key string.
        
        Args:
            kpub: The extended public key (xpub/kpub format).
            cosigner_index: Optional cosigner index for multisig.
        
        Returns:
            PublicKeyGenerator: A new generator instance.
        
        Raises:
            Exception: If parsing fails.
        """
    @staticmethod
    def from_master_xprv(xprv: str | XPrv, is_multisig: builtins.bool, account_index: builtins.int, cosigner_index: typing.Optional[builtins.int] = None) -> PublicKeyGenerator:
        r"""
        Create a generator from a master extended private key.
        
        Derives the account-level public key and creates a generator.
        
        Args:
            xprv: The master extended private key, as a string or XPrv instance.
            is_multisig: Whether this is for a multisig wallet.
            account_index: The account index to derive.
            cosigner_index: Optional cosigner index for multisig.
        
        Returns:
            PublicKeyGenerator: A new generator instance.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_pubkeys(self, start: builtins.int, end: builtins.int) -> builtins.list[PublicKey]:
        r"""
        Derive a range of receive (external) public keys.
        
        Args:
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[PublicKey]: The derived public keys.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_pubkey(self, index: builtins.int) -> PublicKey:
        r"""
        Derive a receive (external) public key at the given index.
        
        Args:
            index: The address index.
        
        Returns:
            PublicKey: The derived public key.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_pubkeys_as_strings(self, start: builtins.int, end: builtins.int) -> builtins.list[builtins.str]:
        r"""
        Derive a range of receive public keys as hex strings.
        
        Args:
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[str]: The derived public keys as hex.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_pubkey_as_string(self, index: builtins.int) -> builtins.str:
        r"""
        Derive a receive public key as hex string.
        
        Args:
            index: The address index.
        
        Returns:
            str: The public key as hex.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_addresses(self, network_type: str | NetworkType, start: builtins.int, end: builtins.int) -> builtins.list[Address]:
        r"""
        Derive a range of receive addresses.
        
        Args:
            network_type: The network type for address encoding.
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[Address]: The derived addresses.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_address(self, network_type: str | NetworkType, index: builtins.int) -> Address:
        r"""
        Derive a receive address at the given index.
        
        Args:
            network_type: The network type for address encoding.
            index: The address index.
        
        Returns:
            Address: The derived address.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_addresses_as_strings(self, network_type: str | NetworkType, start: builtins.int, end: builtins.int) -> builtins.list[builtins.str]:
        r"""
        Derive a range of receive addresses as strings.
        
        Args:
            network_type: The network type for address encoding.
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[str]: The derived addresses as strings.
        
        Raises:
            Exception: If derivation fails.
        """
    def receive_address_as_string(self, network_type: str | NetworkType, index: builtins.int) -> builtins.str:
        r"""
        Derive a receive address as string.
        
        Args:
            network_type: The network type for address encoding.
            index: The address index.
        
        Returns:
            str: The derived address string.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_pubkeys(self, start: builtins.int, end: builtins.int) -> builtins.list[PublicKey]:
        r"""
        Derive a range of change (internal) public keys.
        
        Args:
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[PublicKey]: The derived public keys.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_pubkey(self, index: builtins.int) -> PublicKey:
        r"""
        Derive a change (internal) public key at the given index.
        
        Args:
            index: The address index.
        
        Returns:
            PublicKey: The derived public key.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_pubkeys_as_strings(self, start: builtins.int, end: builtins.int) -> builtins.list[builtins.str]:
        r"""
        Derive a range of change public keys as hex strings.
        
        Args:
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[str]: The derived public keys as hex.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_pubkey_as_string(self, index: builtins.int) -> builtins.str:
        r"""
        Derive a change public key as hex string.
        
        Args:
            index: The address index.
        
        Returns:
            str: The public key as hex.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_addresses(self, network_type: str | NetworkType, start: builtins.int, end: builtins.int) -> builtins.list[Address]:
        r"""
        Derive a range of change addresses.
        
        Args:
            network_type: The network type for address encoding.
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[Address]: The derived addresses.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_address(self, network_type: str | NetworkType, index: builtins.int) -> Address:
        r"""
        Derive a change address at the given index.
        
        Args:
            network_type: The network type for address encoding.
            index: The address index.
        
        Returns:
            Address: The derived address.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_addresses_as_strings(self, network_type: str | NetworkType, start: builtins.int, end: builtins.int) -> builtins.list[builtins.str]:
        r"""
        Derive a range of change addresses as strings.
        
        Args:
            network_type: The network type for address encoding.
            start: Start index (inclusive).
            end: End index (exclusive).
        
        Returns:
            list[str]: The derived addresses as strings.
        
        Raises:
            Exception: If derivation fails.
        """
    def change_address_as_string(self, network_type: str | NetworkType, index: builtins.int) -> builtins.str:
        r"""
        Derive a change address as string.
        
        Args:
            network_type: The network type for address encoding.
            index: The address index.
        
        Returns:
            str: The derived address string.
        
        Raises:
            Exception: If derivation fails.
        """
    def to_string(self) -> builtins.str:
        r"""
        Get the string representation of this generator.
        
        Returns:
            str: The generator info string.
        """

@typing.final
class PyPsktConsensusClientError(builtins.Exception):
    r"""
    PSKT Consensus Client Error
    """
    ...

@typing.final
class PyPsktCreateNotAllowedError(builtins.Exception):
    r"""
    PSKT Creation Not Allowed Error
    """
    ...

@typing.final
class PyPsktCtorError(builtins.Exception):
    r"""
    PSKT Constructor Error
    """
    ...

@typing.final
class PyPsktCustomError(builtins.Exception):
    r"""
    Custom PSKT Error
    """
    ...

@typing.final
class PyPsktError(builtins.Exception):
    r"""
    PSKT Error
    """
    ...

@typing.final
class PyPsktExpectedStateError(builtins.Exception):
    r"""
    PSKT Expected State Error
    """
    ...

@typing.final
class PyPsktInvalidPayloadError(builtins.Exception):
    r"""
    PSKT Invalid Payload Error
    """
    ...

@typing.final
class PyPsktNotInitializedError(builtins.Exception):
    r"""
    PSKT Not Initialized Error
    """
    ...

@typing.final
class PyPsktStateError(builtins.Exception):
    r"""
    PSKT State Error
    """
    ...

@typing.final
class PyPsktTxNotFinalizedError(builtins.Exception):
    r"""
    PSKT Tx Not Finalized Error
    """
    ...

@typing.final
class Resolver:
    r"""
    A resolver for discovering Kaspa RPC node endpoints.
    
    Resolvers help clients find available nodes on a network by querying
    a list of known resolver URLs. Useful for automatic node discovery
    and load balancing.
    """
    def __new__(cls, urls: typing.Optional[typing.Sequence[builtins.str]] = None, tls: typing.Optional[builtins.bool] = None) -> Resolver:
        r"""
        Create a new resolver.
        
        Args:
            urls: Optional list of resolver URLs. Uses defaults if not provided.
            tls: Use TLS connections (default: False).
        
        Returns:
            Resolver: A new Resolver instance.
        """
    def urls(self) -> builtins.list[builtins.str]:
        r"""
        Get the list of resolver URLs.
        
        Returns:
            list[str]: The resolver URL list.
        """
    def get_node(self, encoding: str | Encoding, network_id: NetworkId) -> typing.Any:
        r"""
        Get a node descriptor from the resolver (async).
        
        Args:
            encoding: RPC encoding - either a string ("borsh" or "json") or an Encoding enum variant.
            network_id: The network to find a node for.
        
        Returns:
            dict: Node descriptor with connection details.
        
        Raises:
            Exception: If no node is available or resolution fails.
        """
    def get_url(self, encoding: str | Encoding, network_id: NetworkId) -> typing.Any:
        r"""
        Get a node URL from the resolver (async).
        
        Args:
            encoding: RPC encoding - either a string ("borsh" or "json") or an Encoding enum variant.
            network_id: The network to find a node for.
        
        Returns:
            str: The node WebSocket URL.
        
        Raises:
            Exception: If no node is available or resolution fails.
        """

@typing.final
class RpcClient:
    r"""
    WebSocket RPC client for communicating with Kaspa nodes.
    
    Provides methods for querying blockchain state, submitting transactions,
    and subscribing to real-time notifications. Supports both Borsh and JSON
    encodings.
    """
    @property
    def url(self) -> typing.Optional[builtins.str]:
        r"""
        The current connection URL.
        
        Returns:
            str | None: The WebSocket URL, or None if not connected.
        """
    @property
    def resolver(self) -> typing.Optional[Resolver]:
        r"""
        The resolver used for node discovery.
        
        Returns:
            Resolver | None: The resolver, or None if not set.
        """
    @property
    def is_connected(self) -> builtins.bool:
        r"""
        Whether the client is currently connected.
        
        Returns:
            bool: True if connected to a node.
        """
    @property
    def encoding(self) -> builtins.str:
        r"""
        The RPC encoding format.
        
        Returns:
            str: The encoding ("borsh" or "json").
        """
    @property
    def node_id(self) -> typing.Optional[builtins.str]:
        r"""
        The unique identifier of the connected node.
        
        Returns:
            str | None: The node ID, or None if not connected via resolver.
        """
    def __new__(cls, resolver: typing.Optional[Resolver] = None, url: typing.Optional[builtins.str] = None, encoding: str | Encoding | None = Encoding.Borsh, network_id: typing.Optional[NetworkId] = None) -> RpcClient:
        r"""
        Create a new RPC client.
        
        Args:
            resolver: Optional resolver for node discovery.
            url: Optional direct node URL.
            encoding: RPC encoding - either a string ("borsh" or "json") or an Encoding enum variant (default: "borsh").
            network_id: Network identifier (default: "mainnet").
        
        Returns:
            RpcClient: A new RpcClient instance.
        
        Raises:
            Exception: If client creation fails.
        """
    def set_resolver(self, resolver: Resolver) -> None:
        r"""
        Set a new resolver for node discovery.
        
        Args:
            resolver: The resolver to use.
        
        Raises:
            Exception: If setting the resolver fails.
        """
    def set_network_id(self, network_id: NetworkId) -> None:
        r"""
        Set the network ID for the client.
        
        Args:
            network_id: The network identifier.
        
        Raises:
            Exception: If setting the network ID fails.
        """
    def connect(self, block_async_connect: typing.Optional[builtins.bool] = None, strategy: typing.Optional[builtins.str] = None, url: typing.Optional[builtins.str] = None, timeout_duration: typing.Optional[builtins.int] = None, retry_interval: typing.Optional[builtins.int] = None) -> typing.Any:
        r"""
        Connect to a Kaspa node (async).
        
        Args:
            block_async_connect: Block until connected (default: True).
            strategy: Connection strategy ("retry" or "fallback", default: "retry").
            url: Optional URL to connect to (overrides resolver).
            timeout_duration: Connection timeout in milliseconds.
            retry_interval: Retry interval in milliseconds.
        
        Raises:
            Exception: If connection fails.
        """
    def disconnect(self) -> typing.Any:
        r"""
        Disconnect from the node (async).
        
        Raises:
            Exception: If disconnection fails.
        """
    def start(self) -> typing.Any:
        r"""
        Start the RPC client (async).
        
        Raises:
            Exception: If starting fails.
        """
    def stop(self) -> typing.Any:
        r"""
        Stop background RPC services (automatically stopped when invoking RpcClient.disconnect).
        """
    def trigger_abort(self) -> None:
        r"""
        Triggers a disconnection on the underlying WebSocket
        if the WebSocket is in connected state.
        This is intended for debug purposes only.
        Can be used to test application reconnection logic.
        """
    def add_event_listener(self, event: NotificationEvent, callback: typing.Any, *args: typing.Any, **kwargs: typing.Any) -> None:
        r"""
        Register a callback for RPC events.
        
        Args:
            event: Event type as kebab string or NotificationEvent variant. See NotificationEvent for acceptable values.
            callback: Function to call when event occurs.
            *args: Additional arguments to pass to callback.
            **kwargs: Additional keyword arguments to pass to callback.
        
        Raises:
            Exception: If the event type is invalid.
        """
    def remove_event_listener(self, event: NotificationEvent, callback: typing.Optional[typing.Any] = None) -> None:
        r"""
        Remove an event listener.
        
        Args:
            event: Event type as kebab string or NotificationEvent variant. See NotificationEvent for acceptable values.
            callback: Specific callback to remove, or None to remove all.
        
        Raises:
            Exception: If the event type is invalid.
        """
    @staticmethod
    def default_port(encoding: Encoding, network: NetworkType) -> builtins.int:
        r"""
        Get the default RPC port for a given encoding and network type.
        
        Args:
            encoding: RPC encoding format ("borsh" or "json").
            network: Network type (e.g., "mainnet", "testnet-10", "testnet-11").
        
        Returns:
            int: The default port number for the specified configuration.
        """
    def remove_all_event_listeners(self) -> None:
        r"""
        Remove all registered event listeners.
        """
    def subscribe_utxos_changed(self, addresses: typing.Sequence[Address]) -> typing.Any:
        r"""
        Subscribe to UTXO changes for specific addresses (async).
        
        Args:
            addresses: List of addresses to monitor.
        
        Raises:
            Exception: If not connected or subscription fails.
        """
    def unsubscribe_utxos_changed(self, addresses: typing.Sequence[Address]) -> typing.Any:
        r"""
        Unsubscribe from UTXO changes for specific addresses (async).
        
        Args:
            addresses: List of addresses to stop monitoring.
        
        Raises:
            Exception: If not connected or unsubscription fails.
        """
    def subscribe_virtual_chain_changed(self, include_accepted_transaction_ids: builtins.bool) -> typing.Any:
        r"""
        Subscribe to virtual chain changes (async).
        
        Args:
            include_accepted_transaction_ids: Include transaction IDs in notifications.
        
        Raises:
            Exception: If not connected or subscription fails.
        """
    def unsubscribe_virtual_chain_changed(self, include_accepted_transaction_ids: builtins.bool) -> typing.Any:
        r"""
        Unsubscribe from virtual chain changes (async).
        
        Args:
            include_accepted_transaction_ids: Must match the subscription parameter.
        
        Raises:
            Exception: If not connected or unsubscription fails.
        """
    def subscribe_block_added(self) -> typing.Any: ...
    def unsubscribe_block_added(self) -> typing.Any: ...
    def subscribe_finality_conflict(self) -> typing.Any: ...
    def unsubscribe_finality_conflict(self) -> typing.Any: ...
    def subscribe_finality_conflict_resolved(self) -> typing.Any: ...
    def unsubscribe_finality_conflict_resolved(self) -> typing.Any: ...
    def subscribe_new_block_template(self) -> typing.Any: ...
    def unsubscribe_new_block_template(self) -> typing.Any: ...
    def subscribe_pruning_point_utxo_set_override(self) -> typing.Any: ...
    def unsubscribe_pruning_point_utxo_set_override(self) -> typing.Any: ...
    def subscribe_sink_blue_score_changed(self) -> typing.Any: ...
    def unsubscribe_sink_blue_score_changed(self) -> typing.Any: ...
    def subscribe_virtual_daa_score_changed(self) -> typing.Any: ...
    def unsubscribe_virtual_daa_score_changed(self) -> typing.Any: ...
    def get_block_count(self, request: GetBlockCountRequest | None = None) -> GetBlockCountResponse: ...
    def get_block_dag_info(self, request: GetBlockDagInfoRequest | None = None) -> GetBlockDagInfoResponse: ...
    def get_coin_supply(self, request: GetCoinSupplyRequest | None = None) -> GetCoinSupplyResponse: ...
    def get_connected_peer_info(self, request: GetConnectedPeerInfoRequest | None = None) -> GetConnectedPeerInfoResponse: ...
    def get_info(self, request: GetInfoRequest | None = None) -> GetInfoResponse: ...
    def get_peer_addresses(self, request: GetPeerAddressesRequest | None = None) -> GetPeerAddressesResponse: ...
    def get_metrics(self, request: GetMetricsRequest | None = None) -> GetMetricsResponse: ...
    def get_connections(self, request: GetConnectionsRequest | None = None) -> GetConnectionsResponse: ...
    def get_sink(self, request: GetSinkRequest | None = None) -> GetSinkResponse: ...
    def get_sink_blue_score(self, request: GetSinkBlueScoreRequest | None = None) -> GetSinkBlueScoreResponse: ...
    def ping(self, request: PingRequest | None = None) -> PingResponse: ...
    def shutdown(self, request: ShutdownRequest | None = None) -> ShutdownResponse: ...
    def get_server_info(self, request: GetServerInfoRequest | None = None) -> GetServerInfoResponse: ...
    def get_sync_status(self, request: GetSyncStatusRequest | None = None) -> GetSyncStatusResponse: ...
    def get_fee_estimate(self, request: GetFeeEstimateRequest | None = None) -> GetFeeEstimateResponse: ...
    def get_current_network(self, request: GetCurrentNetworkRequest | None = None) -> GetCurrentNetworkResponse: ...
    def get_system_info(self, request: GetSystemInfoRequest | None = None) -> GetSystemInfoResponse: ...
    def add_peer(self, request: AddPeerRequest) -> AddPeerResponse: ...
    def ban(self, request: BanRequest) -> BanResponse: ...
    def estimate_network_hashes_per_second(self, request: EstimateNetworkHashesPerSecondRequest) -> EstimateNetworkHashesPerSecondResponse: ...
    def get_balance_by_address(self, request: GetBalanceByAddressRequest) -> GetBalanceByAddressResponse: ...
    def get_balances_by_addresses(self, request: GetBalancesByAddressesRequest) -> GetBalancesByAddressesResponse: ...
    def get_block(self, request: GetBlockRequest) -> GetBlockResponse: ...
    def get_blocks(self, request: GetBlocksRequest) -> GetBlocksResponse: ...
    def get_block_template(self, request: GetBlockTemplateRequest) -> GetBlockTemplateResponse: ...
    def get_current_block_color(self, request: GetCurrentBlockColorRequest) -> GetCurrentBlockColorResponse: ...
    def get_daa_score_timestamp_estimate(self, request: GetDaaScoreTimestampEstimateRequest) -> GetDaaScoreTimestampEstimateResponse: ...
    def get_fee_estimate_experimental(self, request: GetFeeEstimateExperimentalRequest) -> GetFeeEstimateExperimentalResponse: ...
    def get_headers(self, request: GetHeadersRequest) -> GetHeadersResponse: ...
    def get_mempool_entries(self, request: GetMempoolEntriesRequest) -> GetMempoolEntriesResponse: ...
    def get_mempool_entries_by_addresses(self, request: GetMempoolEntriesByAddressesRequest) -> GetMempoolEntriesByAddressesResponse: ...
    def get_mempool_entry(self, request: GetMempoolEntryRequest) -> GetMempoolEntryResponse: ...
    def get_subnetwork(self, request: GetSubnetworkRequest) -> GetSubnetworkResponse: ...
    def get_utxos_by_addresses(self, request: GetUtxosByAddressesRequest) -> GetUtxosByAddressesResponse: ...
    def get_utxo_return_address(self, request: GetUtxoReturnAddressRequest) -> GetUtxoReturnAddressResponse: ...
    def get_virtual_chain_from_block(self, request: GetVirtualChainFromBlockRequest) -> GetVirtualChainFromBlockResponse: ...
    def get_virtual_chain_from_block_v2(self, request: GetVirtualChainFromBlockV2Request) -> GetVirtualChainFromBlockV2Response: ...
    def resolve_finality_conflict(self, request: ResolveFinalityConflictRequest) -> ResolveFinalityConflictResponse: ...
    def submit_block(self, request: SubmitBlockRequest) -> SubmitBlockResponse: ...
    def submit_transaction(self, request: SubmitTransactionRequest) -> SubmitTransactionResponse: ...
    def submit_transaction_replacement(self, request: SubmitTransactionReplacementRequest) -> SubmitTransactionReplacementResponse: ...
    def unban(self, request: UnbanRequest) -> UnbanResponse: ...

@typing.final
class ScriptBuilder:
    r"""
    Builder for constructing transaction scripts.
    
    Provides a fluent interface for building custom scripts with opcodes and data.
    Used for creating complex spending conditions like multi-signature or time-locked
    transactions.
    """
    def __new__(cls) -> ScriptBuilder:
        r"""
        Create a new empty script builder.
        
        Returns:
            ScriptBuilder: A new empty ScriptBuilder instance.
        """
    @staticmethod
    def from_script(script: Binary) -> ScriptBuilder:
        r"""
        Create a script builder from an existing script.
        
        Args:
            script: Existing script bytes as hex, bytes, or list.
        
        Returns:
            ScriptBuilder: A new ScriptBuilder initialized with the script.
        """
    def add_op(self, op: typing.Any) -> ScriptBuilder:
        r"""
        Add a single opcode to the script.
        
        Args:
            op: An Opcodes enum value or integer.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If the opcode is invalid.
        """
    def add_ops(self, opcodes: typing.Any) -> ScriptBuilder:
        r"""
        Add multiple opcodes to the script.
        
        Args:
            opcodes: List of Opcodes enum values or integers.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If any opcode is invalid.
        """
    def add_data(self, data: Binary) -> ScriptBuilder:
        r"""
        Add data to the script with appropriate push opcodes.
        
        Args:
            data: Data bytes as hex, bytes, or list.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If the data cannot be added.
        """
    def add_i64(self, value: builtins.int) -> ScriptBuilder:
        r"""
        Add an integer value to the script.
        
        Args:
            value: The integer to add.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If the value cannot be added.
        """
    def add_lock_time(self, lock_time: builtins.int) -> ScriptBuilder:
        r"""
        Add a lock time value for CLTV (CheckLockTimeVerify).
        
        Args:
            lock_time: DAA score or timestamp for time lock.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If the lock time cannot be added.
        """
    def add_sequence(self, sequence: builtins.int) -> ScriptBuilder:
        r"""
        Add a sequence value for CSV (CheckSequenceVerify).
        
        Args:
            sequence: Relative time lock value.
        
        Returns:
            ScriptBuilder: Self for method chaining.
        
        Raises:
            Exception: If the sequence cannot be added.
        """
    @staticmethod
    def canonical_data_size(data: Binary) -> builtins.int:
        r"""
        Calculate the canonical size for data in a script.
        
        Args:
            data: Data bytes.
        
        Returns:
            int: The size in bytes including push opcodes.
        """
    def to_string(self) -> builtins.str:
        r"""
        Get the script as a hex string.
        
        Returns:
            str: The script bytes as a hex string.
        """
    def drain(self) -> builtins.str:
        r"""
        Drain and return the script, clearing the builder.
        
        Returns:
            str: The script as a string.
        """
    def create_pay_to_script_hash_script(self) -> ScriptPublicKey:
        r"""
        Create a P2SH (pay-to-script-hash) locking script.
        
        Returns:
            ScriptPublicKey: The locking script for a P2SH address.
        """
    def encode_pay_to_script_hash_signature_script(self, signature: Binary) -> builtins.str:
        r"""
        Encode a P2SH signature script for spending.
        
        Args:
            signature: The signature bytes.
        
        Returns:
            str: The encoded signature script as hex.
        
        Raises:
            Exception: If encoding fails.
        """
    def __eq__(self, other: ScriptBuilder) -> builtins.bool: ...

@typing.final
class ScriptPublicKey:
    r"""
    A script public key.
    
    Represents the locking conditions for an output. This script defines
    the conditions that must be met to spend the associated funds.
    """
    @property
    def script(self) -> builtins.str:
        r"""
        The script bytes as a hex string.
        
        Returns:
            str: The script data encoded as hexadecimal.
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, version: builtins.int, script: Binary) -> ScriptPublicKey:
        r"""
        Create a new script public key.
        
        Args:
            version: The script version number.
            script: The script bytes.
        
        Returns:
            ScriptPublicKey: A new ScriptPublicKey instance.
        """
    def __str__(self) -> builtins.str:
        r"""
        The string representation.
        
        Returns:
            str: The address as a hex string
        """
    def __bytes__(self) -> bytes:
        r"""
        The byte representation
        """

@typing.final
class Transaction:
    r"""
    A Kaspa transaction.
    
    Represents a complete transaction with inputs, outputs, and metadata.
    Transactions are the fundamental unit of value transfer on the Kaspa network.
    """
    @property
    def id(self) -> builtins.str:
        r"""
        The transaction ID (hash).
        
        Returns:
            str: The transaction ID as a hex string.
        """
    @property
    def inputs(self) -> builtins.list[TransactionInput]:
        r"""
        The list of transaction inputs.
        
        Returns:
            list[TransactionInput]: List of inputs spending previous outputs.
        """
    @inputs.setter
    def inputs(self, value: builtins.list[TransactionInput]) -> None:
        r"""
        Set the transaction inputs.
        
        Args:
            value: List of TransactionInput objects.
        """
    @property
    def outputs(self) -> builtins.list[TransactionOutput]:
        r"""
        The list of transaction outputs.
        
        Returns:
            list[TransactionOutput]: List of outputs defining value destinations.
        """
    @outputs.setter
    def outputs(self, value: builtins.list[TransactionOutput]) -> None:
        r"""
        Set the transaction outputs.
        
        Args:
            value: List of TransactionOutput objects.
        """
    @property
    def version(self) -> builtins.int:
        r"""
        The transaction version number.
        
        Returns:
            int: The version number.
        """
    @version.setter
    def version(self, value: builtins.int) -> None:
        r"""
        Set the transaction version number.
        
        Args:
            value: The version number.
        """
    @property
    def lock_time(self) -> builtins.int:
        r"""
        The transaction lock time.
        Represents a DAA score or Unix timestamp before which the transaction cannot be included.
        
        Returns:
            int: The lock time value.
        """
    @lock_time.setter
    def lock_time(self, value: builtins.int) -> None:
        r"""
        Set the transaction lock time.
        
        Args:
            value: The lock time (DAA score or Unix timestamp).
        """
    @property
    def gas(self) -> builtins.int:
        r"""
        The gas limit for smart contract execution.
        
        Returns:
            int: The gas limit.
        """
    @gas.setter
    def gas(self, value: builtins.int) -> None:
        r"""
        Set the gas limit for smart contract execution.
        
        Args:
            value: The gas limit.
        """
    @property
    def subnetwork(self) -> builtins.str:
        r"""
        The subnetwork identifier.
        
        Returns:
            str: The subnetwork ID as a hex string.
        """
    @property
    def payload(self) -> builtins.str:
        r"""
        The transaction payload data.
        
        Returns:
            str: The payload as a hex string.
        """
    @payload.setter
    def payload(self, value: Binary) -> None:
        r"""
        Set the transaction payload data.
        
        Args:
            value: The payload as bytes or hex string.
        """
    @property
    def mass(self) -> builtins.int:
        r"""
        The transaction mass used for fee calculation.
        
        Returns:
            int: The transaction mass.
        """
    @mass.setter
    def mass(self, value: builtins.int) -> None:
        r"""
        Set the transaction mass.
        
        Args:
            value: The transaction mass value.
        """
    @subnetwork_id.setter
    def subnetwork_id(self, value: builtins.str) -> None:
        r"""
        Set the subnetwork identifier.
        
        Args:
            value: The subnetwork ID as a hex string.
        
        Raises:
            Exception: If the hex string is invalid or has incorrect length.
        """
    def is_coinbase(self) -> builtins.bool:
        r"""
        Check if this is a coinbase transaction.
        
        Returns:
            bool: True if this is a coinbase (mining reward) transaction.
        """
    def finalize(self) -> Hash:
        r"""
        Finalize the transaction and compute its ID.
        
        Returns:
            Hash: The computed transaction ID.
        """
    def __new__(cls, version: builtins.int, inputs: typing.Sequence[TransactionInput], outputs: typing.Sequence[TransactionOutput], lock_time: builtins.int, subnetwork_id: Binary, gas: builtins.int, payload: Binary, mass: builtins.int) -> Transaction:
        r"""
        Create a new transaction.
        
        Args:
            version: Transaction version number.
            inputs: List of transaction inputs.
            outputs: List of transaction outputs.
            lock_time: Lock time (block DAA score or timestamp).
            subnetwork_id: Subnetwork identifier (hex string or bytes).
            gas: Gas limit for smart contract execution.
            payload: Optional transaction payload data.
            mass: Transaction mass (for fee calculation).
        
        Returns:
            Transaction: A new Transaction instance.
        
        Raises:
            Exception: If the subnetwork_id is invalid or transaction creation fails.
        """
    def addresses(self, network_type: str | NetworkType) -> builtins.list[Address]:
        r"""
        Extract unique addresses from transaction inputs.
        
        Args:
            network_type: The network type to use for address encoding.
        
        Returns:
            list[Address]: List of unique addresses referenced by inputs.
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the Transaction.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the Transaction in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> Transaction:
        r"""
        Create a Transaction from a dictionary.
        
        Args:
            dict: Dictionary containing transaction fields with keys:
                - 'id' (str): Transaction ID as hex string
                - 'version' (int): Transaction version number
                - 'inputs' (list[dict]): List of input dictionaries
                - 'outputs' (list[dict]): List of output dictionaries
                - 'lockTime' (int): Lock time value
                - 'subnetworkId' (str): Subnetwork ID as hex string
                - 'gas' (int): Gas limit
                - 'payload' (str): Payload as hex string
                - 'mass' (int): Transaction mass
        
        Returns:
            Transaction: A new Transaction instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """
    def __eq__(self, other: Transaction) -> builtins.bool: ...

@typing.final
class TransactionInput:
    r"""
    A transaction input referencing a previous output.
    
    Inputs reference UTXOs (unspent transaction outputs) that are being spent.
    """
    @property
    def previous_outpoint(self) -> TransactionOutpoint:
        r"""
        The outpoint referencing the UTXO being spent.
        
        Returns:
            TransactionOutpoint: The previous output reference.
        """
    @previous_outpoint.setter
    def previous_outpoint(self, value: TransactionOutpoint) -> None:
        r"""
        Set the outpoint referencing the UTXO being spent.
        
        Args:
            value: The previous output reference.
        """
    @property
    def signature_script_as_hex(self) -> typing.Optional[builtins.str]:
        r"""
        The unlocking script (signature) that proves ownership of the UTXO.
        
        Returns:
            str | None: The signature script as a hex string, or None if not set.
        """
    @property
    def sequence(self) -> builtins.int:
        r"""
        The sequence number used for relative time locks.
        
        Returns:
            int: The sequence number.
        """
    @sequence.setter
    def sequence(self, value: builtins.int) -> None:
        r"""
        Set the sequence number.
        
        Args:
            value: The sequence number for relative time locks.
        """
    @property
    def sig_op_count(self) -> builtins.int:
        r"""
        The number of signature operations in this input.
        
        Returns:
            int: The signature operation count.
        """
    @sig_op_count.setter
    def sig_op_count(self, value: builtins.int) -> None:
        r"""
        Set the signature operation count.
        
        Args:
            value: The number of signature operations.
        """
    @property
    def utxo(self) -> typing.Optional[UtxoEntryReference]:
        r"""
        The UTXO entry reference for transaction signing.
        
        Returns:
            UtxoEntryReference | None: The UTXO reference, or None if not set.
        """
    @signature_script.setter
    def signature_script(self, value: Binary) -> None:
        r"""
        Set the unlocking script (signature).
        
        Args:
            value: The signature script as bytes or hex string.
        """
    def __new__(cls, previous_outpoint: TransactionOutpoint, signature_script: Binary, sequence: builtins.int, sig_op_count: builtins.int, utxo: typing.Optional[UtxoEntryReference] = None) -> TransactionInput:
        r"""
        Create a new transaction input.
        
        Args:
            previous_outpoint: Reference to the UTXO being spent.
            signature_script: The unlocking script (signature).
            sequence: Sequence number for relative time locks.
            sig_op_count: Number of signature operations.
            utxo: Optional UTXO entry reference for signing.
        
        Returns:
            TransactionInput: A new TransactionInput instance.
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the TransactionInput.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the TransactionInput in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> TransactionInput:
        r"""
        Create a TransactionInput from a dictionary.
        
        Args:
            dict: Dictionary containing transaction input fields with keys:
                - 'previousOutpoint' (dict): Dict with 'transactionId' (str) and 'index' (int) keys
                - 'signatureScript' (str | None): The signature script as hex string
                - 'sequence' (int): Sequence number
                - 'sigOpCount' (int): Signature operation count
                - 'utxo' (dict | None): Optional UTXO entry reference dict
        
        Returns:
            TransactionInput: A new TransactionInput instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """
    def __eq__(self, other: TransactionInput) -> builtins.bool: ...

@typing.final
class TransactionOutpoint:
    r"""
    Reference to a specific output in a previous transaction.
    
    An outpoint uniquely identifies a UTXO by its transaction ID and output index.
    """
    @property
    def transaction_id(self) -> builtins.str:
        r"""
        The ID of the transaction containing the referenced output.
        
        Returns:
            str: The transaction ID as a hex string.
        """
    @property
    def index(self) -> builtins.int:
        r"""
        The index of the output within the transaction.
        
        Returns:
            int: The output index.
        """
    def __new__(cls, transaction_id: Hash, index: builtins.int) -> TransactionOutpoint:
        r"""
        Create a new transaction outpoint.
        
        Args:
            transaction_id: The ID of the transaction containing the output.
            index: The index of the output within the transaction.
        
        Returns:
            TransactionOutpoint: A new TransactionOutpoint instance.
        """
    def get_id(self) -> builtins.str:
        r"""
        Get the unique identifier string for this outpoint.
        
        Returns:
            str: A string in format "transaction_id-index".
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the TransactionOutpoint.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the TransactionOutpoint in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> TransactionOutpoint:
        r"""
        Create a TransactionOutpoint from a dictionary.
        
        Args:
            dict: Dictionary containing transaction outpoint fields with keys:
                - 'transactionId' (str): The transaction ID as hex string
                - 'index' (int): The output index
        
        Returns:
            TransactionOutpoint: A new TransactionOutpoint instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """
    def __eq__(self, other: TransactionOutpoint) -> builtins.bool: ...

@typing.final
class TransactionOutput:
    r"""
    A transaction output defining a payment destination.
    
    Outputs specify an amount and a locking script (script_public_key)
    that defines the conditions for spending.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        The output value in sompi (1 KAS = 100,000,000 sompi).
        
        Returns:
            int: The amount in sompi.
        """
    @value.setter
    def value(self, value: builtins.int) -> None:
        r"""
        Set the output value.
        
        Args:
            value: The amount in sompi.
        """
    @property
    def script_public_key(self) -> ScriptPublicKey:
        r"""
        The locking script that defines spending conditions.
        
        Returns:
            ScriptPublicKey: The script public key.
        """
    @script_public_key.setter
    def script_public_key(self, value: ScriptPublicKey) -> None:
        r"""
        Set the locking script.
        
        Args:
            value: The script public key.
        """
    def __new__(cls, value: builtins.int, script_public_key: ScriptPublicKey) -> TransactionOutput:
        r"""
        Create a new transaction output.
        
        Args:
            value: Amount in sompi (1 KAS = 100,000,000 sompi).
            script_public_key: The locking script.
        
        Returns:
            TransactionOutput: A new TransactionOutput instance.
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the TransactionOutput.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the TransactionOutput in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> TransactionOutput:
        r"""
        Create a TransactionOutput from a dictionary.
        
        Args:
            dict: Dictionary containing transaction output fields with keys:
                - 'value' (int): The output value in sompi
                - 'scriptPublicKey' (dict): Dict with 'version' (int) and 'script' (str) keys
        
        Returns:
            TransactionOutput: A new TransactionOutput instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """
    def __eq__(self, other: TransactionOutput) -> builtins.bool: ...

@typing.final
class UtxoContext:
    r"""
    UTXO context for tracking addresses and balances.
    """
    @property
    def is_active(self) -> builtins.bool:
        r"""
        Whether the underlying processor is connected and running.
        """
    @property
    def mature_length(self) -> builtins.int:
        r"""
        Number of mature UTXO entries.
        """
    @property
    def balance(self) -> typing.Optional[Balance]:
        r"""
        Current balance for this context (if available).
        """
    @property
    def balance_strings(self) -> typing.Optional[BalanceStrings]:
        r"""
        Current balance formatted as strings (if available).
        """
    def __new__(cls, processor: UtxoProcessor, id: typing.Optional[typing.Any] = None) -> UtxoContext:
        r"""
        Create a new UtxoContext.
        
        Args:
            processor: The UtxoProcessor to bind to.
            id: Optional 32-byte hex id (string) or Hash.
        """
    def track_addresses(self, addresses: Sequence[Address] | Sequence[str], current_daa_score: typing.Optional[builtins.int] = None) -> typing.Any:
        r"""
        Track and scan a list of addresses (async).
        
        Args:
            addresses: List of Address objects or address strings.
            current_daa_score: Optional current DAA score for scan context.
        """
    def unregister_addresses(self, addresses: Sequence[Address] | Sequence[str]) -> typing.Any:
        r"""
        Unregister a list of addresses (async).
        """
    def clear(self) -> typing.Any:
        r"""
        Clear all tracked addresses and UTXOs (async).
        """
    def mature_range(self, from_: builtins.int, to: builtins.int) -> builtins.list[UtxoEntryReference]:
        r"""
        Return a range of mature UTXO entries.
        """

@typing.final
class UtxoEntries:
    r"""
    UTXO entries collection for flexible input handling.
    
    This type is not intended to be instantiated directly from Python.
    It serves as a helper type that allows Rust functions to accept a list
    of UTXO entries in multiple convenient forms.
    
    Accepts:
        list[UtxoEntryReference]: A list of UtxoEntryReference objects.
        list[dict]: A list of dicts with UtxoEntryReference-compatible keys.
    """
    ...

@typing.final
class UtxoEntries:
    r"""
    A collection of UTXO entry references.
    
    Provides methods for managing and querying multiple UTXOs.
    """
    @property
    def items(self) -> builtins.list[UtxoEntryReference]:
        r"""
        The list of UTXO entry references.
        
        Returns:
            list[UtxoEntryReference]: List of UTXO references.
        """
    @items.setter
    def items(self, value: builtins.list[UtxoEntryReference]) -> None:
        r"""
        Set the list of UTXO entry references.
        
        Args:
            value: List of UtxoEntryReference objects.
        """
    def sort(self) -> None:
        r"""
        Sort the UTXO entries by amount in ascending order.
        """
    def amount(self) -> builtins.int:
        r"""
        Calculate the total amount of all UTXOs.
        
        Returns:
            int: The sum of all UTXO values in sompi.
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the UtxoEntries.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the UtxoEntries in dictionary form.
        """
    def __eq__(self, other: UtxoEntries) -> builtins.bool: ...

@typing.final
class UtxoEntry:
    r"""
    An unspent transaction output (UTXO).
    
    Represents a spendable output from a previous transaction.
    Contains information about the amount, locking script, and block position.
    """
    @property
    def address(self) -> typing.Optional[Address]:
        r"""
        The address associated with this UTXO.
        
        Returns:
            Address | None: The address, or None if not available.
        """
    @property
    def outpoint(self) -> TransactionOutpoint:
        r"""
        The outpoint identifying this UTXO.
        
        Returns:
            TransactionOutpoint: The transaction outpoint reference.
        """
    @property
    def amount(self) -> builtins.int:
        r"""
        The amount in sompi (1 KAS = 100,000,000 sompi).
        
        Returns:
            int: The UTXO value in sompi.
        """
    @property
    def script_public_key(self) -> ScriptPublicKey:
        r"""
        The locking script for this UTXO.
        
        Returns:
            ScriptPublicKey: The script public key.
        """
    @property
    def block_daa_score(self) -> builtins.int:
        r"""
        The DAA score of the block containing this UTXO.
        
        Returns:
            int: The block DAA score.
        """
    @property
    def is_coinbase(self) -> builtins.bool:
        r"""
        Whether this UTXO is from a coinbase transaction.
        
        Returns:
            bool: True if this is a coinbase UTXO.
        """
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the UtxoEntry.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the UtxoEntry in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> UtxoEntry:
        r"""
        Create a UtxoEntry from a dictionary.
        
        Args:
            dict: Dictionary containing utxo entry fields with keys:
                - 'address' (str | None): The address string
                - 'outpoint' (dict): Transaction outpoint with 'transactionId' and 'index'
                - 'amount' (int): The UTXO value in sompi
                - 'scriptPublicKey' (dict): Dict with 'version' (int) and 'script' (str) keys
                - 'blockDaaScore' (int): Block DAA score
                - 'isCoinbase' (bool): Whether from coinbase transaction
        
        Returns:
            UtxoEntry: A new UtxoEntry instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """
    def __eq__(self, other: UtxoEntry) -> builtins.bool: ...

@typing.final
class UtxoEntryReference:
    r"""
    A reference to a UTXO entry.
    
    Provides access to UTXO data for transaction building and signing.
    """
    @property
    def entry(self) -> UtxoEntry:
        r"""
        The underlying UTXO entry.
        
        Returns:
            UtxoEntry: The UTXO entry data.
        """
    @property
    def outpoint(self) -> TransactionOutpoint:
        r"""
        The outpoint identifying this UTXO.
        
        Returns:
            TransactionOutpoint: The transaction outpoint reference.
        """
    @property
    def address(self) -> typing.Optional[Address]:
        r"""
        The address associated with this UTXO.
        
        Returns:
            Address | None: The address, or None if not available.
        """
    @property
    def amount(self) -> builtins.int:
        r"""
        The amount in sompi (1 KAS = 100,000,000 sompi).
        
        Returns:
            int: The UTXO value in sompi.
        """
    @property
    def is_coinbase(self) -> builtins.bool:
        r"""
        Whether this UTXO is from a coinbase transaction.
        
        Returns:
            bool: True if this is a coinbase UTXO.
        """
    @property
    def block_daa_score(self) -> builtins.int:
        r"""
        The DAA score of the block containing this UTXO.
        
        Returns:
            int: The block DAA score.
        """
    @property
    def script_public_key(self) -> ScriptPublicKey:
        r"""
        The locking script for this UTXO.
        
        Returns:
            ScriptPublicKey: The script public key.
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Get a dictionary representation of the UtxoEntryReference.
        Note that this creates a second separate object on the Python heap.
        
        Returns:
            dict: the UtxoEntryReference in dictionary form.
        """
    @classmethod
    def from_dict(cls, dict: dict) -> UtxoEntryReference:
        r"""
        Create a UtxoEntryReference from a dictionary.
        
        Supports two formats:
        
        Flat format:
            - 'address' (str | None): The address string
            - 'outpoint' (dict): Transaction outpoint with 'transactionId' and 'index'
            - 'amount' (int): The UTXO value in sompi
            - 'scriptPublicKey' (dict | str): Dict with 'version' and 'script', or hex string
            - 'blockDaaScore' (int): Block DAA score
            - 'isCoinbase' (bool): Whether from coinbase transaction
        
        Nested format:
            - 'address' (str | None): The address string
            - 'outpoint' (dict): Transaction outpoint with 'transactionId' and 'index'
            - 'utxoEntry' (dict): Nested dict containing amount, scriptPublicKey, blockDaaScore, isCoinbase
        
        Returns:
            UtxoEntryReference: A new UtxoEntryReference instance.
        
        Raises:
            KeyError: If required keys are missing.
            ValueError: If values are invalid.
        """

@typing.final
class UtxoProcessor:
    r"""
    UTXO processor coordinating address tracking and UTXO updates.
    """
    @property
    def rpc(self) -> RpcClient:
        r"""
        The associated RPC client.
        """
    @property
    def network_id(self) -> typing.Optional[NetworkId]:
        r"""
        The network id used by the processor (if set).
        """
    @property
    def is_active(self) -> builtins.bool:
        r"""
        Whether the processor is connected and running.
        """
    def __new__(cls, rpc: RpcClient, network_id: NetworkId) -> UtxoProcessor:
        r"""
        Create a new UtxoProcessor.
        
        Args:
            rpc: The RPC client to use for network communication.
            network_id: Network identifier for UTXO processing.
        """
    def start(self) -> typing.Any:
        r"""
        Start UTXO processing (async).
        """
    def stop(self) -> typing.Any:
        r"""
        Stop UTXO processing (async).
        """
    def set_network_id(self, network_id: NetworkId) -> None:
        r"""
        Set the network id for the processor.
        """
    @staticmethod
    def set_coinbase_transaction_maturity_daa(network_id: NetworkId, value: builtins.int) -> None:
        r"""
        Set the coinbase transaction maturity period DAA for a network.
        """
    @staticmethod
    def set_user_transaction_maturity_daa(network_id: NetworkId, value: builtins.int) -> None:
        r"""
        Set the user transaction maturity period DAA for a network.
        """

@typing.final
class XOnlyPublicKey:
    r"""
    An x-only public key (32 bytes, Schnorr compatible).
    
    Used for Schnorr signatures and Taproot-style addresses.
    """
    def __new__(cls, key: builtins.str) -> XOnlyPublicKey:
        r"""
        Create an x-only public key from a hex string.
        
        Args:
            key: A 64-character hex string.
        
        Returns:
            XOnlyPublicKey: A new XOnlyPublicKey instance.
        
        Raises:
            Exception: If the hex string is invalid.
        """
    def to_string(self) -> builtins.str:
        r"""
        Convert to hex string representation.
        
        Returns:
            str: The x-only public key as a hex string.
        """
    def to_address(self, network: str | NetworkType) -> Address:
        r"""
        Derive a Schnorr address from this x-only public key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived Schnorr address.
        """
    def to_address_ecdsa(self, network: str | NetworkType) -> Address:
        r"""
        Derive an ECDSA address from this x-only public key.
        
        Args:
            network: The network type for address encoding.
        
        Returns:
            Address: The derived ECDSA address.
        """
    @staticmethod
    def from_address(address: Address) -> XOnlyPublicKey:
        r"""
        Extract an x-only public key from an address.
        
        Args:
            address: A Kaspa address.
        
        Returns:
            XOnlyPublicKey: The extracted public key.
        
        Raises:
            Exception: If extraction fails.
        """

@typing.final
class XPrv:
    r"""
    An extended private key (BIP-32).
    
    Allows hierarchical deterministic key derivation from a seed.
    All keys in an HD wallet can be derived from a single XPrv.
    """
    @property
    def xprv(self) -> builtins.str:
        r"""
        The serialized extended private key string.
        
        Returns:
            str: The xprv string.
        """
    @property
    def private_key(self) -> builtins.str:
        r"""
        The private key as a hex string.
        
        Returns:
            str: The private key hex.
        """
    @property
    def depth(self) -> builtins.int:
        r"""
        The derivation depth (0 for master key).
        
        Returns:
            int: The depth.
        """
    @property
    def parent_fingerprint(self) -> builtins.str:
        r"""
        The parent key's fingerprint as hex.
        
        Returns:
            str: The parent fingerprint.
        """
    @property
    def child_number(self) -> builtins.int:
        r"""
        The child number used to derive this key.
        
        Returns:
            int: The child number.
        """
    @property
    def chain_code(self) -> builtins.str:
        r"""
        The chain code as hex.
        
        Returns:
            str: The chain code.
        """
    def __new__(cls, seed: builtins.str) -> XPrv:
        r"""
        Create an XPrv from a seed hex string.
        
        Args:
            seed: A hex-encoded seed (typically from Mnemonic.to_seed()).
        
        Returns:
            XPrv: A new XPrv instance.
        
        Raises:
            Exception: If the seed is invalid.
        """
    @staticmethod
    def from_xprv(xprv: builtins.str) -> XPrv:
        r"""
        Create an XPrv from a serialized xprv string.
        
        Args:
            xprv: A Base58-encoded extended private key string.
        
        Returns:
            XPrv: A new XPrv instance.
        
        Raises:
            Exception: If the xprv string is invalid.
        """
    def derive_child(self, child_number: builtins.int, hardened: typing.Optional[builtins.bool] = None) -> XPrv:
        r"""
        Derive a child key at the given index.
        
        Args:
            child_number: The child index.
            hardened: Whether to use hardened derivation (default: False).
        
        Returns:
            XPrv: The derived child XPrv.
        
        Raises:
            Exception: If derivation fails.
        """
    def derive_path(self, path: typing.Any) -> XPrv:
        r"""
        Derive a key at the given derivation path.
        
        Args:
            path: A derivation path string (e.g., "m/44'/111111'/0'") or DerivationPath.
        
        Returns:
            XPrv: The derived XPrv at that path.
        
        Raises:
            Exception: If derivation fails.
        """
    def into_string(self, prefix: builtins.str) -> builtins.str:
        r"""
        Serialize to string with custom prefix.
        
        Args:
            prefix: The key prefix (e.g., "kprv", "xprv").
        
        Returns:
            str: The serialized extended private key.
        
        Raises:
            Exception: If serialization fails.
        """
    def to_string(self) -> builtins.str:
        r"""
        Serialize to string with default "kprv" prefix.
        
        Returns:
            str: The serialized extended private key.
        
        Raises:
            Exception: If serialization fails.
        """
    def to_xpub(self) -> XPub:
        r"""
        Get the corresponding extended public key.
        
        Returns:
            XPub: The derived extended public key.
        """
    def to_private_key(self) -> PrivateKey:
        r"""
        Get the private key at this derivation level.
        
        Returns:
            PrivateKey: The private key.
        """

@typing.final
class XPub:
    r"""
    An extended public key (BIP-32).
    
    Allows hierarchical deterministic address generation without
    access to private keys. Useful for watch-only wallets.
    """
    @property
    def xpub(self) -> builtins.str:
        r"""
        The serialized extended public key string.
        
        Returns:
            str: The xpub string.
        """
    @property
    def depth(self) -> builtins.int:
        r"""
        The derivation depth (0 for master key).
        
        Returns:
            int: The depth.
        """
    @property
    def parent_fingerprint(self) -> builtins.str:
        r"""
        The parent key's fingerprint as hex.
        
        Returns:
            str: The parent fingerprint.
        """
    @property
    def child_number(self) -> builtins.int:
        r"""
        The child number used to derive this key.
        
        Returns:
            int: The child number.
        """
    @property
    def chain_code(self) -> builtins.str:
        r"""
        The chain code as hex.
        
        Returns:
            str: The chain code.
        """
    def __new__(cls, xpub: builtins.str) -> XPub:
        r"""
        Create an XPub from a serialized xpub string.
        
        Args:
            xpub: A Base58-encoded extended public key string.
        
        Returns:
            XPub: A new XPub instance.
        
        Raises:
            Exception: If the xpub string is invalid.
        """
    def derive_child(self, child_number: builtins.int, hardened: typing.Optional[builtins.bool] = None) -> XPub:
        r"""
        Derive a child key at the given index.
        
        Note: Extended public keys can only derive non-hardened children.
        
        Args:
            child_number: The child index.
            hardened: Whether to use hardened derivation (default: False).
        
        Returns:
            XPub: The derived child XPub.
        
        Raises:
            Exception: If derivation fails (e.g., hardened from xpub).
        """
    def derive_path(self, path: builtins.str) -> XPub:
        r"""
        Derive a key at the given derivation path.
        
        Args:
            path: A derivation path string (non-hardened only).
        
        Returns:
            XPub: The derived XPub at that path.
        
        Raises:
            Exception: If derivation fails.
        """
    def into_string(self, prefix: builtins.str) -> builtins.str:
        r"""
        Serialize to string with custom prefix.
        
        Args:
            prefix: The key prefix (e.g., "kpub", "xpub").
        
        Returns:
            str: The serialized extended public key.
        
        Raises:
            Exception: If serialization fails.
        """
    def to_public_key(self) -> PublicKey:
        r"""
        Get the public key at this derivation level.
        
        Returns:
            PublicKey: The public key.
        """

@typing.final
class NotificationEvent(enum.Enum):
    r"""
    Notification event types for RPC client subscriptions.
    
    Use with `RpcClient.subscribe()` and `RpcClient.unsubscribe()` to manage
    event subscriptions for real-time updates from a Kaspa node.
    
    Variants:
        - All: Subscribe to all available notification events at once.
        - BlockAdded: Triggered when a new block is added to the DAG.
        - VirtualChainChanged: Triggered when the virtual (selected parent) chain changes.
        - FinalityConflict: Triggered when a finality conflict is detected.
        - FinalityConflictResolved: Triggered when a finality conflict is resolved.
        - UtxosChanged: Triggered when UTXOs for subscribed addresses change.
        - SinkBlueScoreChanged: Triggered when the sink block's blue score changes.
        - VirtualDaaScoreChanged: Triggered when the virtual DAA score changes.
        - PruningPointUtxoSetOverride: Triggered when the pruning point UTXO set is overridden.
        - NewBlockTemplate: Triggered when a new block template is available for mining.
        - Connect: Triggered when the RPC client connects to a node.
        - Disconnect: Triggered when the RPC client disconnects from a node.
    """
    All = ...
    BlockAdded = ...
    VirtualChainChanged = ...
    FinalityConflict = ...
    FinalityConflictResolved = ...
    UtxosChanged = ...
    SinkBlueScoreChanged = ...
    VirtualDaaScoreChanged = ...
    PruningPointUtxoSetOverride = ...
    NewBlockTemplate = ...
    Connect = ...
    Disconnect = ...

@typing.final
class AddressVersion(enum.Enum):
    r"""
    Kaspa Address version (`PubKey`, `PubKeyECDSA`, `ScriptHash`)
    -  PubKey addresses always have the version byte set to 0
    - PubKey ECDSA addresses always have the version byte set to 1
    - ScriptHash addresses always have the version byte set to 8
    """
    PubKey = ...
    PubKeyECDSA = ...
    ScriptHash = ...

@typing.final
class Encoding(enum.Enum):
    r"""
    wRPC protocol encoding
    """
    Borsh = ...
    SerdeJson = ...

@typing.final
class Language(enum.Enum):
    r"""
    BIP-39 mnemonic word list language.
    """
    English = ...

@typing.final
class NetworkType(enum.Enum):
    r"""
    Kaspa network type enumeration.
    """
    Mainnet = ...
    Testnet = ...
    Devnet = ...
    Simnet = ...

    def default_rpc_port(self) -> builtins.int: ...
    def default_borsh_rpc_port(self) -> builtins.int: ...
    def default_json_rpc_port(self) -> builtins.int: ...

@typing.final
class Opcodes(enum.Enum):
    r"""
    Ccript opcodes for transaction scripting.
    
    These opcodes are used in ScriptBuilder to construct locking and
    unlocking scripts for Kaspa transactions.
    """
    OpFalse = ...
    OpData1 = ...
    OpData2 = ...
    OpData3 = ...
    OpData4 = ...
    OpData5 = ...
    OpData6 = ...
    OpData7 = ...
    OpData8 = ...
    OpData9 = ...
    OpData10 = ...
    OpData11 = ...
    OpData12 = ...
    OpData13 = ...
    OpData14 = ...
    OpData15 = ...
    OpData16 = ...
    OpData17 = ...
    OpData18 = ...
    OpData19 = ...
    OpData20 = ...
    OpData21 = ...
    OpData22 = ...
    OpData23 = ...
    OpData24 = ...
    OpData25 = ...
    OpData26 = ...
    OpData27 = ...
    OpData28 = ...
    OpData29 = ...
    OpData30 = ...
    OpData31 = ...
    OpData32 = ...
    OpData33 = ...
    OpData34 = ...
    OpData35 = ...
    OpData36 = ...
    OpData37 = ...
    OpData38 = ...
    OpData39 = ...
    OpData40 = ...
    OpData41 = ...
    OpData42 = ...
    OpData43 = ...
    OpData44 = ...
    OpData45 = ...
    OpData46 = ...
    OpData47 = ...
    OpData48 = ...
    OpData49 = ...
    OpData50 = ...
    OpData51 = ...
    OpData52 = ...
    OpData53 = ...
    OpData54 = ...
    OpData55 = ...
    OpData56 = ...
    OpData57 = ...
    OpData58 = ...
    OpData59 = ...
    OpData60 = ...
    OpData61 = ...
    OpData62 = ...
    OpData63 = ...
    OpData64 = ...
    OpData65 = ...
    OpData66 = ...
    OpData67 = ...
    OpData68 = ...
    OpData69 = ...
    OpData70 = ...
    OpData71 = ...
    OpData72 = ...
    OpData73 = ...
    OpData74 = ...
    OpData75 = ...
    OpPushData1 = ...
    OpPushData2 = ...
    OpPushData4 = ...
    Op1Negate = ...
    OpReserved = ...
    OpTrue = ...
    Op2 = ...
    Op3 = ...
    Op4 = ...
    Op5 = ...
    Op6 = ...
    Op7 = ...
    Op8 = ...
    Op9 = ...
    Op10 = ...
    Op11 = ...
    Op12 = ...
    Op13 = ...
    Op14 = ...
    Op15 = ...
    Op16 = ...
    OpNop = ...
    OpVer = ...
    OpIf = ...
    OpNotIf = ...
    OpVerIf = ...
    OpVerNotIf = ...
    OpElse = ...
    OpEndIf = ...
    OpVerify = ...
    OpReturn = ...
    OpToAltStack = ...
    OpFromAltStack = ...
    Op2Drop = ...
    Op2Dup = ...
    Op3Dup = ...
    Op2Over = ...
    Op2Rot = ...
    Op2Swap = ...
    OpIfDup = ...
    OpDepth = ...
    OpDrop = ...
    OpDup = ...
    OpNip = ...
    OpOver = ...
    OpPick = ...
    OpRoll = ...
    OpRot = ...
    OpSwap = ...
    OpTuck = ...
    OpCat = ...
    OpSubStr = ...
    OpLeft = ...
    OpRight = ...
    OpSize = ...
    OpInvert = ...
    OpAnd = ...
    OpOr = ...
    OpXor = ...
    OpEqual = ...
    OpEqualVerify = ...
    OpReserved1 = ...
    OpReserved2 = ...
    Op1Add = ...
    Op1Sub = ...
    Op2Mul = ...
    Op2Div = ...
    OpNegate = ...
    OpAbs = ...
    OpNot = ...
    Op0NotEqual = ...
    OpAdd = ...
    OpSub = ...
    OpMul = ...
    OpDiv = ...
    OpMod = ...
    OpLShift = ...
    OpRShift = ...
    OpBoolAnd = ...
    OpBoolOr = ...
    OpNumEqual = ...
    OpNumEqualVerify = ...
    OpNumNotEqual = ...
    OpLessThan = ...
    OpGreaterThan = ...
    OpLessThanOrEqual = ...
    OpGreaterThanOrEqual = ...
    OpMin = ...
    OpMax = ...
    OpWithin = ...
    OpUnknown166 = ...
    OpUnknown167 = ...
    OpSHA256 = ...
    OpCheckMultiSigECDSA = ...
    OpBlake2b = ...
    OpCheckSigECDSA = ...
    OpCheckSig = ...
    OpCheckSigVerify = ...
    OpCheckMultiSig = ...
    OpCheckMultiSigVerify = ...
    OpCheckLockTimeVerify = ...
    OpCheckSequenceVerify = ...
    OpUnknown178 = ...
    OpUnknown179 = ...
    OpUnknown180 = ...
    OpUnknown181 = ...
    OpUnknown182 = ...
    OpUnknown183 = ...
    OpUnknown184 = ...
    OpUnknown185 = ...
    OpUnknown186 = ...
    OpUnknown187 = ...
    OpUnknown188 = ...
    OpUnknown189 = ...
    OpUnknown190 = ...
    OpUnknown191 = ...
    OpUnknown192 = ...
    OpUnknown193 = ...
    OpUnknown194 = ...
    OpUnknown195 = ...
    OpUnknown196 = ...
    OpUnknown197 = ...
    OpUnknown198 = ...
    OpUnknown199 = ...
    OpUnknown200 = ...
    OpUnknown201 = ...
    OpUnknown202 = ...
    OpUnknown203 = ...
    OpUnknown204 = ...
    OpUnknown205 = ...
    OpUnknown206 = ...
    OpUnknown207 = ...
    OpUnknown208 = ...
    OpUnknown209 = ...
    OpUnknown210 = ...
    OpUnknown211 = ...
    OpUnknown212 = ...
    OpUnknown213 = ...
    OpUnknown214 = ...
    OpUnknown215 = ...
    OpUnknown216 = ...
    OpUnknown217 = ...
    OpUnknown218 = ...
    OpUnknown219 = ...
    OpUnknown220 = ...
    OpUnknown221 = ...
    OpUnknown222 = ...
    OpUnknown223 = ...
    OpUnknown224 = ...
    OpUnknown225 = ...
    OpUnknown226 = ...
    OpUnknown227 = ...
    OpUnknown228 = ...
    OpUnknown229 = ...
    OpUnknown230 = ...
    OpUnknown231 = ...
    OpUnknown232 = ...
    OpUnknown233 = ...
    OpUnknown234 = ...
    OpUnknown235 = ...
    OpUnknown236 = ...
    OpUnknown237 = ...
    OpUnknown238 = ...
    OpUnknown239 = ...
    OpUnknown240 = ...
    OpUnknown241 = ...
    OpUnknown242 = ...
    OpUnknown243 = ...
    OpUnknown244 = ...
    OpUnknown245 = ...
    OpUnknown246 = ...
    OpUnknown247 = ...
    OpUnknown248 = ...
    OpUnknown249 = ...
    OpSmallInteger = ...
    OpPubKeys = ...
    OpUnknown252 = ...
    OpPubKeyHash = ...
    OpPubKey = ...
    OpInvalidOpCode = ...

    @property
    def value(self) -> builtins.int: ...

@typing.final
class SighashType(enum.Enum):
    r"""
    Kaspa signature hash types for transaction signing.
    """
    All = ...
    _None = ...
    Single = ...
    AllAnyOneCanPay = ...
    NoneAnyOneCanPay = ...
    SingleAnyOneCanPay = ...

def address_from_script_public_key(script_public_key: ScriptPublicKey, network: str | NetworkType) -> Address:
    r"""
    Extract the address from a script public key.
    
    Args:
        script_public_key: The script to extract the address from.
        network: The network type for address encoding.
    
    Returns:
        Address: The extracted address.
    
    Raises:
        Exception: If address extraction fails.
    """

def calculate_storage_mass(network_id: NetworkId, input_values: typing.Sequence[builtins.int], output_values: typing.Sequence[builtins.int]) -> typing.Optional[builtins.int]:
    r"""
    Calculate the storage mass for a transaction.
    
    Storage mass penalizes transactions that increase the UTXO set size
    or create many small outputs.
    
    Args:
        network_id: The network identifier.
        input_values: List of input values in sompi.
        output_values: List of output values in sompi.
    
    Returns:
        int | None: The storage mass, or None if not applicable.
    """

def calculate_transaction_fee(network_id: NetworkId, tx: Transaction, minimum_signatures: typing.Optional[builtins.int] = None) -> typing.Optional[builtins.int]:
    r"""
    Calculate the fee for an unsigned transaction based on its mass.
    
    Args:
        network_id: The network identifier.
        tx: The transaction to calculate fee for.
        minimum_signatures: Minimum signatures per input (default: 1).
    
    Returns:
        int | None: The fee in sompi, or None if mass exceeds limits.
    
    Raises:
        Exception: If mass calculation fails.
    """

def calculate_transaction_mass(network_id: NetworkId, tx: Transaction, minimum_signatures: typing.Optional[builtins.int] = None) -> builtins.int:
    r"""
    Calculate the mass of an unsigned transaction.
    
    Args:
        network_id: The network identifier.
        tx: The transaction to calculate mass for.
        minimum_signatures: Minimum signatures per input (default: 1).
    
    Returns:
        int: The calculated transaction mass.
    
    Raises:
        Exception: If mass calculation fails.
    """

def create_input_signature(tx: Transaction, input_index: builtins.int, private_key: PrivateKey, sighash_type: str | SighashType | None = SighashType.All) -> builtins.str:
    r"""
    Create a signature for a specific transaction input.
    
    Args:
        tx: The transaction containing the input to sign.
        input_index: The index of the input to sign.
        private_key: The private key for signing.
        sighash_type: The signature hash type (default: All).
    
    Returns:
        str: The signature as a hex string.
    
    Raises:
        Exception: If signing fails.
    """

def create_multisig_address(minimum_signatures: builtins.int, keys: typing.Sequence[PublicKey], network_type: str | NetworkType, ecdsa: typing.Optional[builtins.bool] = False, account_kind: typing.Optional[AccountKind] = None) -> Address:
    r"""
    Create a multisig address from multiple public keys.
    
    Args:
        minimum_signatures: The minimum number of signatures required to spend.
        keys: List of public keys for the multisig.
        network_type: The network type for address encoding.
        ecdsa: Use ECDSA signatures instead of Schnorr (default: False).
        account_kind: Optional account kind for derivation.
    
    Returns:
        Address: The multisig address.
    
    Raises:
        Exception: If address creation fails.
    """

def create_transaction(utxo_entry_source: UtxoEntries, outputs: Outputs, priority_fee: builtins.int, payload: typing.Optional[Binary] = None, sig_op_count: typing.Optional[builtins.int] = None) -> Transaction:
    r"""
    Create a single transaction from UTXOs.
    
    Args:
        utxo_entry_source: List of UTXO entries to spend.
        outputs: List of payment outputs.
        priority_fee: Priority fee in sompi.
        payload: Optional transaction payload data.
        sig_op_count: Signature operations per input (default: 1).
    
    Returns:
        Transaction: The created transaction (unsigned).
    
    Raises:
        Exception: If transaction creation fails or fee exceeds input amount.
    """

def create_transactions(network_id: NetworkId, entries: UtxoEntries, change_address: Address, outputs: typing.Optional[Outputs] = None, payload: typing.Optional[Binary] = None, fee_rate: typing.Optional[builtins.float] = None, priority_fee: typing.Optional[builtins.int] = None, priority_entries: typing.Optional[UtxoEntries] = None, sig_op_count: typing.Optional[builtins.int] = None, minimum_signatures: typing.Optional[builtins.int] = None) -> dict:
    r"""
    Create one or more transactions with automatic UTXO selection and change handling.
    
    Handles large transfers that may require multiple transactions due to mass limits.
    
    Args:
        network_id: The network to build transactions for.
        entries: List of UTXO entries to spend from.
        change_address: Address to send change to.
        outputs: Optional list of payment outputs.
        payload: Optional transaction payload data.
        fee_rate: Optional fee rate multiplier.
        priority_fee: Additional fee in sompi.
        priority_entries: UTXOs to use first.
        sig_op_count: Signature operations per input (default: 1).
        minimum_signatures: For multisig fee estimation.
    
    Returns:
        dict: Dictionary with "transactions" (list) and "summary" keys.
    
    Raises:
        Exception: If transaction creation fails.
    """

def estimate_transactions(network_id: NetworkId, entries: UtxoEntries, change_address: Address, outputs: typing.Optional[Outputs] = None, payload: typing.Optional[Binary] = None, fee_rate: typing.Optional[builtins.float] = None, priority_fee: typing.Optional[builtins.int] = None, priority_entries: typing.Optional[UtxoEntries] = None, sig_op_count: typing.Optional[builtins.int] = None, minimum_signatures: typing.Optional[builtins.int] = None) -> GeneratorSummary:
    r"""
    Estimate transaction fees and count without creating transactions.
    
    Args:
        network_id: The network to estimate for.
        entries: List of UTXO entries to spend from.
        change_address: Address to send change to.
        outputs: Optional list of payment outputs.
        payload: Optional transaction payload data.
        fee_rate: Optional fee rate multiplier.
        priority_fee: Additional fee in sompi.
        priority_entries: UTXOs to use first.
        sig_op_count: Signature operations per input (default: 1).
        minimum_signatures: For multisig fee estimation.
    
    Returns:
        GeneratorSummary: Summary with fee, transaction count, and other details.
    
    Raises:
        Exception: If estimation fails.
    """

def is_script_pay_to_pubkey(script: Binary) -> builtins.bool:
    r"""
    Check if a script is a pay-to-pubkey (P2PK) script.
    
    Args:
        script: The script bytes to check.
    
    Returns:
        bool: True if the script is a P2PK script.
    """

def is_script_pay_to_pubkey_ecdsa(script: Binary) -> builtins.bool:
    r"""
    Check if a script is a pay-to-pubkey-ECDSA script.
    
    Args:
        script: The script bytes to check.
    
    Returns:
        bool: True if the script is a P2PK-ECDSA script.
    """

def is_script_pay_to_script_hash(script: Binary) -> builtins.bool:
    r"""
    Check if a script is a pay-to-script-hash (P2SH) script.
    
    Args:
        script: The script bytes to check.
    
    Returns:
        bool: True if the script is a P2SH script.
    """

def kaspa_to_sompi(kaspa: builtins.float) -> builtins.int:
    r"""
    Convert KAS to sompi (1 KAS = 100,000,000 sompi).
    
    Args:
        kaspa: The amount in KAS.
    
    Returns:
        int: The amount in sompi.
    """

def maximum_standard_transaction_mass() -> builtins.int:
    r"""
    Get the maximum allowed mass for a standard transaction.
    
    Returns:
        int: The maximum standard transaction mass.
    """

def pay_to_address_script(address: Address) -> ScriptPublicKey:
    r"""
    Create a pay-to-address locking script.
    
    Args:
        address: The destination address.
    
    Returns:
        ScriptPublicKey: The locking script for the address.
    """

def pay_to_script_hash_script(redeem_script: Binary) -> ScriptPublicKey:
    r"""
    Create a pay-to-script-hash (P2SH) locking script.
    
    Args:
        redeem_script: The redeem script to hash.
    
    Returns:
        ScriptPublicKey: The P2SH locking script.
    """

def pay_to_script_hash_signature_script(redeem_script: Binary, signature: Binary) -> builtins.str:
    r"""
    Create a signature script for spending a P2SH output.
    
    Args:
        redeem_script: The original redeem script.
        signature: The signature proving authorization.
    
    Returns:
        str: The signature script as a hex string.
    
    Raises:
        Exception: If script creation fails.
    """

def sign_message(message: builtins.str, private_key: PrivateKey, no_aux_rand: builtins.bool = False) -> builtins.str:
    r"""
    Sign an arbitrary message with a private key.
    
    Args:
        message: The message string to sign.
        private_key: The private key to sign with.
        no_aux_rand: If True, use deterministic signing (default: False).
    
    Returns:
        str: The signature as a hex string.
    
    Raises:
        Exception: If signing fails.
    """

def sign_script_hash(script_hash: builtins.str, privkey: PrivateKey) -> builtins.str:
    r"""
    Sign a script hash with a private key.
    
    Args:
        script_hash: The script hash to sign as a hex string.
        privkey: The private key for signing.
    
    Returns:
        str: The signature as a hex string.
    
    Raises:
        Exception: If signing fails.
    """

def sign_transaction(tx: Transaction, signer: list, verify_sig: builtins.bool) -> Transaction:
    r"""
    Sign a transaction with one or more private keys.
    
    Args:
        tx: The transaction to sign.
        signer: List of PrivateKey objects for signing.
        verify_sig: Whether to verify signatures after signing.
    
    Returns:
        Transaction: The signed transaction.
    
    Raises:
        Exception: If signing or verification fails.
    """

def sompi_to_kaspa(sompi: builtins.int) -> builtins.float:
    r"""
    Convert sompi to KAS (1 KAS = 100,000,000 sompi).
    
    Args:
        sompi: The amount in sompi.
    
    Returns:
        float: The amount in KAS.
    """

def sompi_to_kaspa_string_with_suffix(sompi: builtins.int, network: str | NetworkType) -> builtins.str:
    r"""
    Convert sompi to a formatted KAS string with network suffix.
    
    Args:
        sompi: The amount in sompi.
        network: The network type for the suffix.
    
    Returns:
        str: Formatted string like "1.5 KAS" or "1.5 TKAS".
    """

def update_transaction_mass(network_id: NetworkId, tx: Transaction, minimum_signatures: typing.Optional[builtins.int] = None) -> builtins.bool:
    r"""
    Calculate and update the mass field of an unsigned transaction.
    
    Args:
        network_id: The network identifier.
        tx: The transaction to update.
        minimum_signatures: Minimum signatures per input (default: 1).
    
    Returns:
        bool: True if mass is within limits and was updated, False if too large.
    
    Raises:
        Exception: If mass calculation fails.
    """

def verify_message(message: builtins.str, signature: builtins.str, public_key: PublicKey) -> builtins.bool:
    r"""
    Verify a message signature.
    
    Args:
        message: The original message.
        signature: The signature hex string.
        public_key: The public key to verify against.
    
    Returns:
        bool: True if the signature is valid, False otherwise.
    
    Raises:
        Exception: If the signature format is invalid.
    """

# =============================================================================
# RPC Types (from kaspa_rpc.pyi)
# =============================================================================

"""
TypedDict definitions for Kaspa RPC request/response messages & contained types.

This file is maunally maintained and appended to kaspa.pyi file via stub gen process.

Long term, attempts should be made to auto generate.
"""

from enum import Enum
from typing import TypedDict


# =============================================================================
# Shared / Nested Types
# =============================================================================

class RpcOutpoint(TypedDict):
    """A transaction outpoint (reference to a specific output)."""
    transactionId: str
    index: int


class RpcScriptPublicKey(TypedDict):
    """A script public key."""
    version: int
    script: str


class RpcUtxoEntry(TypedDict):
    """A UTXO entry."""
    amount: int
    scriptPublicKey: RpcScriptPublicKey
    blockDaaScore: int
    isCoinbase: bool


class RpcUtxosByAddressesEntry(TypedDict):
    """A UTXO entry associated with an address."""
    address: str
    outpoint: RpcOutpoint
    utxoEntry: RpcUtxoEntry


class RpcBalancesByAddressesEntry(TypedDict):
    """Balance information for a specific address."""
    address: str
    balance: int


class RpcFeeRateBucket(TypedDict):
    """A fee rate bucket for fee estimation."""
    feerate: float
    estimatedSeconds: float


class RpcFeeEstimate(TypedDict):
    """Fee estimation with priority, normal, and low buckets."""
    priorityBucket: RpcFeeRateBucket
    normalBuckets: list[RpcFeeRateBucket]
    lowBuckets: list[RpcFeeRateBucket]


class RpcVerboseData(TypedDict):
    """Represent Kaspa transaction input verbose data"""
    ...


class RpcTransactionInput(TypedDict):
    """A transaction input."""
    previousOutpoint: RpcOutpoint
    signatureScript: str
    sequence: int
    sigOpCount: int
    verboseData: RpcVerboseData | None


class RpcTransactionOutputVerboseData(TypedDict):
    """Verbose data for a transaction output."""
    scriptPublicKeyType: str
    scriptPublicKeyAddress: str


class RpcTransactionOutput(TypedDict):
    """A transaction output."""
    value: int
    scriptPublicKey: str
    verboseData: RpcTransactionOutputVerboseData | None


class RpcTransaction(TypedDict):
    """A transaction."""
    version: int
    inputs: list[RpcTransactionInput]
    outputs: list[RpcTransactionOutput]
    lockTime: int
    subnetworkId: str
    gas: int
    payload: str
    mass: int
    verboseData: RpcTransactionVerboseData | None


class RpcTransactionVerboseData(TypedDict, total=False):
    """Verbose transaction data."""
    transactionId: str
    hash: str
    computeMass: int
    blockHash: str
    blockTime: int


class RpcBlockHeader(TypedDict):
    """A block header."""
    hash: str
    version: int
    parentsByLevel: list[list[str]]
    hashMerkleRoot: str
    acceptedIdMerkleRoot: str
    utxoCommitment: str
    timestamp: int
    bits: int
    nonce: int
    daaScore: int
    blueWork: str
    blueScore: int
    pruningPoint: str


class RpcBlockVerboseData(TypedDict, total=False):
    """Verbose block data."""
    hash: str
    difficulty: float
    selectedParentHash: str
    transactionIds: list[str]
    isHeaderOnly: bool
    blueScore: int
    childrenHashes: list[str]
    mergeSetBluesHashes: list[str]
    mergeSetRedsHashes: list[str]
    isChainBlock: bool


class RpcBlock(TypedDict):
    """A block."""
    header: RpcBlockHeader
    transactions: list[RpcTransaction]
    verboseData: RpcBlockVerboseData | None


class RpcRawHeader(TypedDict):
    """A raw block header without a cached hash."""
    version: int
    parentsByLevel: list[list[str]]
    hashMerkleRoot: str
    acceptedIdMerkleRoot: str
    utxoCommitment: str
    timestamp: int
    bits: int
    nonce: int
    daaScore: int
    blueWork: str
    blueScore: int
    pruningPoint: str


class RpcRawBlock(TypedDict):
    """
        Raw Rpc block type - without a cached header hash and without verbose data.
        Used for mining APIs (get_block_template & submit_block)
    """
    header: RpcRawHeader
    transactions: list[RpcTransaction]


class RpcMempoolEntry(TypedDict):
    """A mempool entry."""
    fee: int
    transaction: RpcTransaction
    is_orphan: bool


class RpcMempoolEntryByAddress(TypedDict):
    """Mempool entries for a specific address."""
    address: str
    sending: list[RpcMempoolEntry]
    receiving: list[RpcMempoolEntry]


class RpcAcceptedTransactionIds(TypedDict):
    """Accepted transaction IDs for a block."""
    acceptingBlockHash: str
    acceptedTransactionIds: list[str]


class ProcessMetrics(TypedDict):
    """Process metrics.
    
    Category: RPC/Types
    """
    residentSetSize: int
    virtualMemorySize: int
    coreNum: int
    cpuUsage: float
    fdNum: int
    diskIoReadBytes: int
    diskIoWriteBytes: int
    diskIoReadPerSec: float
    diskIoWritePerSec: float


class RpcStorageMetrics(TypedDict):
    """Storage metrics."""
    storageSizeBytes: int


class ConsensusMetrics(TypedDict):
    """Consensus metrics.
    
    Category: RPC/Types
    """
    nodeBlocksSubmittedCount: int
    nodeHeadersProcessedCount: int
    nodeDependenciesProcessedCount: int
    nodeBodiesProcessedCount: int
    nodeTransactionsProcessedCount: int
    nodeChainBlocksProcessedCount: int
    nodeMassProcessedCount: int
    nodeDatabaseBlocksCount: int
    nodeDatabaseHeadersCount: int
    networkMempoolSize: int
    networkTipHashesCount: int
    networkDifficulty: float
    networkPastMedianTime: int
    networkVirtualParentHashesCount: int
    networkVirtualDaaScore: int


class ConnectionMetrics(TypedDict):
    """Connection metrics.
    
    Category: RPC/Types
    """
    borshLiveConnections: int
    borshConnectionAttempts: int
    borshHandshakeFailures: int
    jsonLiveConnections: int
    jsonConnectionAttempts: int
    jsonHandshakeFailures: int
    activePeers: int


class RpcPeerInfo(TypedDict):
    """Peer information."""
    id: str
    address: RpcPeerAddress
    last_ping_duration: int
    is_outbound: bool
    time_offset: int
    user_agent: str
    advertised_protocol_version: int
    time_connected: int
    is_ibd_peer: bool


class BandwidthMetrics(TypedDict):
    """Bandwidth metrics for various protocols.
    
    Category: RPC/Types
    """
    borshBytesTx: int
    borshBytesRx: int
    jsonBytesTx: int
    jsonBytesRx: int
    p2pBytesTx: int
    p2pBytesRx: int
    grpcBytesTx: int
    grpcBytesRx: int


class RpcPeerAddress(TypedDict):
    """A peer address."""
    ip: str
    port: int


class RpcDataVerbosityLevel(Enum):
    """Verbosity level for GetVirtualChainFromBlockV2Request"""
    _None = 0,
    Low = 1,
    High = 2,
    Full = 3,


class RpcOptionalHeader(TypedDict):
    """Represents a block header with optional fields populated based on verbosity level.

    Fields are included based on the RpcDataVerbosityLevel specified in the request.
    Each attribute is only populated when the verbosity level meets or exceeds
    the required level for that field.

    Attributes:
        hash: The block hash. Level: None (always included).
        version: Block version number. Level: Low.
        parentsByLevel: Compressed parent block hashes by level. Level: High.
        hashMerkleRoot: Merkle root of block hashes. Level: High.
        acceptedIdMerkleRoot: Merkle root of accepted transaction IDs. Level: High.
        utxoCommitment: UTXO commitment hash. Level: Full.
        timestamp: Block timestamp in milliseconds. Level: Low.
        bits: Difficulty target bits. Level: Low.
        nonce: Block nonce. Level: Low.
        daaScore: Difficulty adjustment algorithm score. Level: Low.
        blueWork: Cumulative blue work. Level: Low.
        blueScore: Blue score of the block. Level: Low.
        pruningPoint: Pruning point block hash. Level: Full.
    """
    hash: str | None
    version: int | None
    parentsByLevel: list[tuple[int, list[str]]] | None
    hashMerkleRoot: str | None
    acceptedIdMerkleRoot: str | None
    utxoCommitment: str | None
    timestamp: int | None
    bits: int | None
    nonce: int | None
    daaScore: int | None
    blueWork: str | None
    blueScore: int | None
    pruningPoint: str | None


class RpcOptionalTransactionOutpoint(TypedDict):
    """Represents a Kaspa transaction outpoint"""
    transactionId: str | None
    index: int | None


class RpcOptionalUtxoEntryVerboseData(TypedDict):
    """Represents verbose data for a UTXO entry with optional fields based on verbosity level.

    Attributes:
        scriptPublicKeyType: The type/class of the script public key. Level: Low.
        scriptPublicKeyAddress: The address derived from the script public key. Level: Low.
    """
    scriptPublicKeyType: str | None
    scriptPublicKeyAddress: str | None


class RpcOptionalUtxoEntry(TypedDict):
    """Represents a UTXO entry with optional fields based on verbosity level.

    Attributes:
        amount: The amount in sompi. Level: High.
        scriptPublicKey: The script public key. Level: High.
        blockDaaScore: The DAA score of the block containing this UTXO. Level: Full.
        isCoinbase: Whether this UTXO is from a coinbase transaction. Level: High.
        verboseData: Additional verbose data for this UTXO entry.
    """
    amount: int | None
    scriptPublicKey: str | None
    blockDaaScore: int | None
    isCoinbase: bool | None
    verboseData: RpcOptionalUtxoEntryVerboseData | None


class RpcOptionalTransactionInputVerboseData(TypedDict):
    """Represent Kaspa transaction input verbose data"""
    utxoEntry: RpcOptionalUtxoEntry | None


class RpcOptionalTransactionOutputVerboseData(TypedDict):
    """Represents verbose data for a transaction output with optional fields based on verbosity level.

    Attributes:
        scriptPublicKeyType: The type/class of the script public key. Level: Low.
        scriptPublicKeyAddress: The address derived from the script public key. Level: Low.
    """
    scriptPublicKeyType: str | None
    scriptPublicKeyAddress: str | None


class RpcOptionalTransactionOutput(TypedDict):
    """Represents a transaction output with optional fields based on verbosity level.

    Attributes:
        value: The output value in sompi. Level: Low.
        scriptPublicKey: The script public key for this output. Level: Low.
        verboseData: Additional verbose data for this output.
    """
    value: int | None
    scriptPublicKey: str | None
    verboseData: RpcOptionalTransactionOutputVerboseData | None


class RpcOptionalTransactionInput(TypedDict):
    """Represents a transaction input with optional fields based on verbosity level.

    Attributes:
        previousOutpoint: The outpoint being spent. Level: High.
        signatureScript: The signature script (hex encoded). Level: Low.
        sequence: The sequence number. Level: High.
        sigOpCount: The signature operation count. Level: High.
        verboseData: Additional verbose data for this input.
    """
    previousOutpoint: RpcOptionalTransactionOutpoint | None # TODO
    signatureScript: str | None
    sequence: int | None
    sigOpCount: int | None
    verboseData: RpcOptionalTransactionInputVerboseData | None # TODO


class RpcOptionalTransactionVerboseData(TypedDict):
    """Represents verbose data for a transaction with optional fields based on verbosity level.

    Attributes:
        transactionId: The transaction ID. Level: Low.
        hash: The transaction hash. Level: Low.
        computeMass: The computed mass of the transaction. Level: High.
        blockHash: The hash of the block containing this transaction. Level: Low.
        blockTime: The timestamp of the block containing this transaction. Level: Low.
    """
    transactionId: str | None
    hash: str | None
    computeMass: int | None
    blockHash: str | None
    blockTime: int | None


class RpcOptionalTransaction(TypedDict):
    """Represents a transaction with optional fields based on verbosity level.

    Attributes:
        version: The transaction version. Level: Full.
        inputs: List of transaction inputs.
        outputs: List of transaction outputs.
        lockTime: The lock time of the transaction. Level: Full.
        subnetworkId: The subnetwork ID. Level: Full.
        gas: The gas limit. Level: Full.
        payload: The transaction payload (hex encoded). Level: High.
        mass: The transaction mass. Level: High.
        verboseData: Additional verbose data for this transaction.
    """
    version: int | None
    inputs: list[RpcOptionalTransactionInput] | None
    outputs: list[RpcOptionalTransactionOutput] | None
    lockTime: int | None
    subnetworkId: str | None
    gas: int | None
    payload: list[int] | None
    mass: int | None
    verboseData: RpcOptionalTransactionVerboseData | None


class RpcChainBlockAcceptedTransactions(TypedDict):
    """Transaction acceptance data returned by GetVirtualChainFromBlockV2"""
    chainBlockHeader: RpcOptionalHeader
    acceptedTransactions: list[RpcOptionalTransaction]


# =============================================================================
# Request Types
# =============================================================================

class GetBlockCountRequest(TypedDict, total=False):
    """Request for get_block_count."""
    pass


class GetBlockDagInfoRequest(TypedDict, total=False):
    """Request for get_block_dag_info."""
    pass


class GetCoinSupplyRequest(TypedDict, total=False):
    """Request for get_coin_supply."""
    pass


class GetConnectedPeerInfoRequest(TypedDict, total=False):
    """Request for get_connected_peer_info."""
    pass


class GetInfoRequest(TypedDict, total=False):
    """Request for get_info."""
    pass


class GetPeerAddressesRequest(TypedDict, total=False):
    """Request for get_peer_addresses."""
    pass


class GetMetricsRequest(TypedDict, total=False):
    """Request for get_metrics."""
    processMetrics: bool
    connectionMetrics: bool
    bandwidthMetrics: bool
    consensusMetrics: bool
    storageMetrics: bool
    customMetrics: bool


class GetConnectionsRequest(TypedDict, total=False):
    """Request for get_connections."""
    includeProfileData: bool


class GetSinkRequest(TypedDict, total=False):
    """Request for get_sink."""
    pass


class GetSinkBlueScoreRequest(TypedDict, total=False):
    """Request for get_sink_blue_score."""
    pass


class PingRequest(TypedDict, total=False):
    """Request for ping."""
    pass


class ShutdownRequest(TypedDict, total=False):
    """Request for shutdown."""
    pass


class GetServerInfoRequest(TypedDict, total=False):
    """Request for get_server_info."""
    pass


class GetSyncStatusRequest(TypedDict, total=False):
    """Request for get_sync_status."""
    pass


class GetFeeEstimateRequest(TypedDict, total=False):
    """Request for get_fee_estimate."""
    pass


class GetCurrentNetworkRequest(TypedDict, total=False):
    """Request for get_current_network."""
    pass


class GetSystemInfoRequest(TypedDict, total=False):
    """Request for get_system_info."""
    pass


class AddPeerRequest(TypedDict):
    """Request for add_peer."""
    peerAddress: str
    isPermanent: bool


class BanRequest(TypedDict):
    """Request for ban."""
    ip: str


class UnbanRequest(TypedDict):
    """Request for unban."""
    ip: str


class EstimateNetworkHashesPerSecondRequest(TypedDict):
    """Request for estimate_network_hashes_per_second."""
    windowSize: int
    startHash: str | None


class GetBalanceByAddressRequest(TypedDict):
    """Request for get_balance_by_address."""
    address: str


class GetBalancesByAddressesRequest(TypedDict):
    """Request for get_balances_by_addresses."""
    addresses: list[str]


class GetBlockRequest(TypedDict):
    """Request for get_block."""
    hash: str
    includeTransactions: bool


class GetBlocksRequest(TypedDict):
    """Request for get_blocks."""
    lowHash: str | None
    includeBlocks: bool
    includeTransactions: bool


class GetBlockTemplateRequest(TypedDict):
    """Request for get_block_template."""
    payAddress: str
    extraData: str


class GetCurrentBlockColorRequest(TypedDict):
    """Request for get_current_block_color."""
    hash: str


class GetDaaScoreTimestampEstimateRequest(TypedDict):
    """Request for get_daa_score_timestamp_estimate."""
    daaScores: list[int]


class GetFeeEstimateExperimentalRequest(TypedDict, total=False):
    """Request for get_fee_estimate_experimental."""
    verbose: bool


class GetHeadersRequest(TypedDict):
    """Request for get_headers."""
    startHash: str
    limit: int
    isAscending: bool


class GetMempoolEntriesRequest(TypedDict):
    """Request for get_mempool_entries."""
    includeOrphanPool: bool
    filterTransactionPool: bool


class GetMempoolEntriesByAddressesRequest(TypedDict):
    """Request for get_mempool_entries_by_addresses."""
    addresses: list[str]
    includeOrphanPool: bool
    filterTransactionPool: bool


class GetMempoolEntryRequest(TypedDict):
    """Request for get_mempool_entry."""
    transactionId: str
    includeOrphanPool: bool
    filterTransactionPool: bool


class GetSubnetworkRequest(TypedDict):
    """Request for get_subnetwork."""
    subnetworkId: str


class GetUtxosByAddressesRequest(TypedDict):
    """Request for get_utxos_by_addresses."""
    addresses: list[str]


class GetUtxoReturnAddressRequest(TypedDict):
    """Request for get_utxo_return_address."""
    transactionId: str


class GetVirtualChainFromBlockRequest(TypedDict):
    """Request for get_virtual_chain_from_block."""
    startHash: str
    includeAcceptedTransactionIds: bool
    minConfirmationCount: int | None


class GetVirtualChainFromBlockV2Request(TypedDict):
    """Request for get_virtual_chain_from_block_v2."""
    startHash: str
    dataVerbosityLevel: RpcDataVerbosityLevel | None
    minConfirmationCount: int | None


class ResolveFinalityConflictRequest(TypedDict):
    """Request for resolve_finality_conflict."""
    finalityBlockHash: str


class SubmitBlockRequest(TypedDict):
    """Request for submit_block."""
    block: RpcBlock
    allowNonDaaBlocks: bool


class SubmitTransactionRequest(TypedDict):
    """Request for submit_transaction."""
    transaction: RpcTransaction
    allowOrphan: bool


class SubmitTransactionReplacementRequest(TypedDict):
    """Request for submit_transaction_replacement."""
    transaction: RpcTransaction


# =============================================================================
# Response Types (returned from RPC methods)
# =============================================================================

class GetBlockCountResponse(TypedDict):
    """Response from get_block_count."""
    blockCount: int
    headerCount: int


class GetBlockDagInfoResponse(TypedDict):
    """Response from get_block_dag_info."""
    network: str
    blockCount: int
    headerCount: int
    tipHashes: list[str]
    difficulty: float
    pastMedianTime: int
    virtualParentHashes: list[str]
    pruningPointHash: str
    virtualDaaScore: int
    sink: str


class GetCoinSupplyResponse(TypedDict):
    """Response from get_coin_supply."""
    maxSompi: int
    circulatingSompi: int


class GetConnectedPeerInfoResponse(TypedDict):
    """Response from get_connected_peer_info."""
    peerInfo: list[RpcPeerInfo]


class GetInfoResponse(TypedDict):
    """Response from get_info."""
    p2pId: str
    mempoolSize: int
    serverVersion: str
    isUtxoIndexed: bool
    isSynced: bool
    hasNotifyCommand: bool
    hasMessageId: bool


class GetPeerAddressesResponse(TypedDict):
    """Response from get_peer_addresses."""
    knownAddresses: list[RpcPeerAddress]
    bannedAddresses: list[RpcPeerAddress]


class GetMetricsResponse(TypedDict, total=False):
    """Response from get_metrics."""
    serverTime: int
    processMetrics: ProcessMetrics
    connectionMetrics: ConnectionMetrics
    bandwidthMetrics: BandwidthMetrics
    consensusMetrics: ConsensusMetrics
    storageMetrics: RpcStorageMetrics
    customMetrics: dict | None


class ConnectionsProfileData(TypedDict):
    """Profile data for connection resource usage.
    
    Category: RPC/Types
    """
    cpuUsage: int
    memoryUsage: int


class GetConnectionsResponse(TypedDict):
    """Response from get_connections."""
    clients: int
    peers: int
    profileData: ConnectionsProfileData | None


class GetSinkResponse(TypedDict):
    """Response from get_sink."""
    sink: str


class GetSinkBlueScoreResponse(TypedDict):
    """Response from get_sink_blue_score."""
    blueScore: int


class PingResponse(TypedDict):
    """Response from ping."""
    pass


class ShutdownResponse(TypedDict):
    """Response from shutdown."""
    pass


class GetServerInfoResponse(TypedDict):
    """Response from get_server_info."""
    rpcApiVersion: int
    rpcApiRevision: int
    serverVersion: str
    networkId: str
    hasUtxoIndex: bool
    isSynced: bool
    virtualDaaScore: int


class GetSyncStatusResponse(TypedDict):
    """Response from get_sync_status."""
    isSynced: bool


class GetFeeEstimateResponse(TypedDict):
    """Response from get_fee_estimate."""
    estimate: RpcFeeEstimate


class GetCurrentNetworkResponse(TypedDict):
    """Response from get_current_network."""
    network: str


class GetSystemInfoResponse(TypedDict):
    """Response from get_system_info."""
    version: str
    systemId: list[int] | None
    gitHash: list[int] | None
    cpuPhysicalCores: int
    totalMemory: int
    fdLimit: int
    proxySocketLimitPerCpuCore: int | None


class AddPeerResponse(TypedDict):
    """Response from add_peer."""
    pass


class BanResponse(TypedDict):
    """Response from ban."""
    pass


class UnbanResponse(TypedDict):
    """Response from unban."""
    pass


class EstimateNetworkHashesPerSecondResponse(TypedDict):
    """Response from estimate_network_hashes_per_second."""
    networkHashesPerSecond: int


class GetBalanceByAddressResponse(TypedDict):
    """Response from get_balance_by_address."""
    balance: int


class GetBalancesByAddressesResponse(TypedDict):
    """Response from get_balances_by_addresses."""
    entries: list[RpcBalancesByAddressesEntry]


class GetBlockResponse(TypedDict):
    """Response from get_block."""
    block: RpcBlock


class GetBlocksResponse(TypedDict):
    """Response from get_blocks."""
    blockHashes: list[str]
    blocks: list[RpcBlock]


class GetBlockTemplateResponse(TypedDict):
    """Response from get_block_template."""
    block: RpcRawBlock
    isSynced: bool


class GetCurrentBlockColorResponse(TypedDict):
    """Response from get_current_block_color."""
    blue: bool


class GetDaaScoreTimestampEstimateResponse(TypedDict):
    """Response from get_daa_score_timestamp_estimate."""
    timestamps: list[int]


class GetFeeEstimateExperimentalResponse(TypedDict):
    """Response from get_fee_estimate_experimental."""
    estimate: RpcFeeEstimate
    verbose: dict | None


class GetHeadersResponse(TypedDict):
    """Response from get_headers."""
    headers: list[RpcBlockHeader]


class GetMempoolEntriesResponse(TypedDict):
    """Response from get_mempool_entries."""
    mempoolEntries: list[RpcMempoolEntry]


class GetMempoolEntriesByAddressesResponse(TypedDict):
    """Response from get_mempool_entries_by_addresses."""
    entries: list[RpcMempoolEntryByAddress]


class GetMempoolEntryResponse(TypedDict):
    """Response from get_mempool_entry."""
    mempoolEntry: RpcMempoolEntry


class GetSubnetworkResponse(TypedDict):
    """Response from get_subnetwork."""
    gasLimit: int


class GetUtxosByAddressesResponse(TypedDict):
    """Response from get_utxos_by_addresses."""
    entries: list[RpcUtxosByAddressesEntry]


class GetUtxoReturnAddressResponse(TypedDict):
    """Response from get_utxo_return_address."""
    returnAddress: str | None


class GetVirtualChainFromBlockResponse(TypedDict):
    """Response from get_virtual_chain_from_block."""
    removedChainBlockHashes: list[str]
    addedChainBlockHashes: list[str]
    acceptedTransactionIds: list[RpcAcceptedTransactionIds]


class GetVirtualChainFromBlockV2Response(TypedDict):
    """Response from get_virtual_chain_from_block_v2."""
    removedChainBlockHashes: list[str]
    addedChainBlockHashes: list[str]
    chainBlockAcceptedTransactions: list[RpcChainBlockAcceptedTransactions]


class ResolveFinalityConflictResponse(TypedDict):
    """Response from resolve_finality_conflict."""
    pass


class SubmitBlockResponse(TypedDict):
    """Response from submit_block."""
    report: str


class SubmitTransactionResponse(TypedDict):
    """Response from submit_transaction."""
    transactionId: str


class SubmitTransactionReplacementResponse(TypedDict):
    """Response from submit_transaction_replacement."""
    transactionId: str
    replacedTransaction: RpcTransaction